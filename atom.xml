<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>东胜神州</title>
  
  <subtitle>价值投资 长期主义 编程 美食 旅行 梦想 参禅 悟道</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://frank2019.github.io/"/>
  <updated>2020-03-04T00:42:08.380Z</updated>
  <id>https://frank2019.github.io/</id>
  
  <author>
    <name>晓光</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>C++基础系列_智能指针shared_ptr</title>
    <link href="https://frank2019.github.io/2020/03/04/c++_shared_ptr/"/>
    <id>https://frank2019.github.io/2020/03/04/c++_shared_ptr/</id>
    <published>2020-03-04T00:51:31.696Z</published>
    <updated>2020-03-04T00:42:08.380Z</updated>
    
    <content type="html"><![CDATA[<p>本文的目标是掌握清楚 智能指针 shared_ptr 和weak_ptr  涉及到的概念和使用。</p><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><h3 id="RAII-Resource-Acquisition-Is-Initialization"><a href="#RAII-Resource-Acquisition-Is-Initialization" class="headerlink" title="RAII(Resource Acquisition Is Initialization)"></a>RAII(Resource Acquisition Is Initialization)</h3><p>RAII 含义即是资源分配即初始化。 </p><ul><li><p>讲的是这样一个理念，将资源的管理放在一个类种，利用类的生命周期构造函数和析构函数来进行资源的管理和释放。用局部对象来表示资源。</p></li><li><p>这是c++ 编程种的最重要编程技法之一。</p></li><li><p>智能指针便是利用 RAII 的技术对普通的指针进行封装，这使得智能指针实质是一个对象，行为表现却像一个指针</p></li></ul><p>C++11 中提供了三种智能指针</p><p>分别是 shared_ptr , unique_ptr 和 weak_ptr 。</p><ol><li>shared_ptr 允许多个指针指向同一个对象，</li><li>unique_ptr 则“独占”所指向的对象，</li><li>weak_ptr 则是和share_ptr 相辅相成的伴随类</li></ol><h2 id="shared-ptr"><a href="#shared-ptr" class="headerlink" title="shared_ptr"></a>shared_ptr</h2><h3 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h3><ol><li>shared_ptr多个智能指针可以指向相同对象；</li><li>能够自动释放所指向的对象</li><li>该对象和其相关资源会在“最后一个引用被销毁”时候释放。</li><li>对象创建完就应该直接交给智能指针管理；</li><li>shared_ptr 采用引用计数器，多个shared_ptr种的 T*ptr 指向同一内存区域(同一对象)，并共同维护同一个引用计数器。</li><li>初始化指针并将引用计数置为1;</li><li>当对象作为另一对象的副本而创建时，拷贝构造函数拷贝指针并增加与之相应的引用计数。</li><li>对一个对象进行赋值时，赋值操作符减少左操作数所指对象的引用计数（如果引用计数为减至0，则删除对象），并增加右操作数所指对象的引用计数；这是因为左侧的指针指向了右侧指针所指向的对象，因此右指针所指向的对象的引用计数加1。调用析构函数时，构造函数减少引用计数（如果引用计数减至0，则删除基础对象）。</li></ol><h4 id="Member-functions"><a href="#Member-functions" class="headerlink" title="Member functions"></a>Member functions</h4><ul><li><p>构造函数      不谈拷贝构造的话，shared_ptr的基本构造方式有4种：</p><ul><li>无参数构造。</li><li>传入一个指针构造一个shared_ptr</li><li>传入一个指针和一个删除器构造一个shared_ptr。</li><li>传入一个指针、一个删除器以及一个allocator构造一个shared_ptr。</li><li>当然还有一些其他的，例如从auto_ptr从weak_ptr从null_ptr构造。</li></ul></li><li><p>析构函数   用来释放智能指针，至于是否释放智能指针所管理的对象，取决于成员use_count的值；</p><ul><li>如果use_count &gt; 1，则引用计数器减一；</li><li>如果use_count=1,则引用计数器置零，资源释放。</li><li>如果use_count=0,则说明此智能指针本来就没有指向对象。</li></ul></li><li><p><a href="http://www.cplusplus.com/reference/memory/shared_ptr/operator=/" target="_blank" rel="noopener"><strong>operator=</strong></a></p><p>赋值操作后，赋值前原来的 _refCount要自减 ， 计数器_refCount要做++ ；</p></li><li><p><a href="http://www.cplusplus.com/reference/memory/shared_ptr/swap/" target="_blank" rel="noopener"><strong>swap</strong></a></p><p>交换，使两个智能指针分别指向对方的对象。</p></li><li><p><a href="http://www.cplusplus.com/reference/memory/shared_ptr/reset/" target="_blank" rel="noopener"><strong>reset</strong></a>    复位操作，不再指向对象，原来所指向对象的_refCount要自减</p></li><li><p><a href="http://www.cplusplus.com/reference/memory/shared_ptr/get/" target="_blank" rel="noopener"><strong>get</strong></a>  获取对象的原始指针。</p></li><li><p><a href="http://www.cplusplus.com/reference/memory/shared_ptr/operator*/" target="_blank" rel="noopener"><strong>operator*</strong></a>  相当于*get()</p></li><li><p><a href="http://www.cplusplus.com/reference/memory/shared_ptr/operator->/" target="_blank" rel="noopener"><strong>operator-&gt;</strong></a>   可以像原指针一样，指向原指针的成员。</p></li><li><p><a href="http://www.cplusplus.com/reference/memory/shared_ptr/use_count/" target="_blank" rel="noopener"><strong>use_count</strong></a>  返回当前所指对象的引用计数。</p></li><li><p><a href="http://www.cplusplus.com/reference/memory/shared_ptr/unique/" target="_blank" rel="noopener"><strong>unique</strong></a>  检查Usecount() == 1</p></li><li><p>[<strong>operator bool</strong>](<a href="http://www.cplusplus.com/reference/memory/shared_ptr/operator" target="_blank" rel="noopener">http://www.cplusplus.com/reference/memory/shared_ptr/operator</a> bool/)  检查 <code>get()!=NULL</code> </p></li><li><p><a href="http://www.cplusplus.com/reference/memory/shared_ptr/owner_before/" target="_blank" rel="noopener"><strong>owner_before</strong></a></p><p>Owner-based ordering (public member function template )</p></li></ul><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">C</span> &#123;</span><span class="keyword">int</span>* data;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; p1;</span><br><span class="line">  <span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; <span class="title">p2</span> <span class="params">(<span class="literal">nullptr</span>)</span></span>;</span><br><span class="line">  <span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; <span class="title">p3</span> <span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>)</span></span>;</span><br><span class="line">  <span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; <span class="title">p4</span> <span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>, <span class="built_in">std</span>::default_delete&lt;<span class="keyword">int</span>&gt;())</span></span>;</span><br><span class="line">  <span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; <span class="title">p5</span> <span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>, [](<span class="keyword">int</span>* p)&#123;<span class="keyword">delete</span> p;&#125;, <span class="built_in">std</span>::allocator&lt;<span class="keyword">int</span>&gt;())</span></span>;</span><br><span class="line">  <span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; <span class="title">p6</span> <span class="params">(p5)</span></span>;</span><br><span class="line">  <span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; <span class="title">p7</span> <span class="params">(<span class="built_in">std</span>::<span class="built_in">move</span>(p6))</span></span>;</span><br><span class="line">  <span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; <span class="title">p8</span> <span class="params">(<span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;<span class="keyword">int</span>&gt;(<span class="keyword">new</span> <span class="keyword">int</span>))</span></span>;</span><br><span class="line">  <span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;C&gt; <span class="title">obj</span> <span class="params">(<span class="keyword">new</span> C)</span></span>;</span><br><span class="line">  <span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; <span class="title">p9</span> <span class="params">(obj, obj-&gt;data)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"use_count:\n"</span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"p1: "</span> &lt;&lt; p1.use_count() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"p2: "</span> &lt;&lt; p2.use_count() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"p3: "</span> &lt;&lt; p3.use_count() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"p4: "</span> &lt;&lt; p4.use_count() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"p5: "</span> &lt;&lt; p5.use_count() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"p6: "</span> &lt;&lt; p6.use_count() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"p7: "</span> &lt;&lt; p7.use_count() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"p8: "</span> &lt;&lt; p8.use_count() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"p9: "</span> &lt;&lt; p9.use_count() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Non-member-functions"><a href="#Non-member-functions" class="headerlink" title="Non-member functions"></a>Non-member functions</h3><ul><li><p><strong>swap</strong>   交换shared_ptr  所指对象</p><p>Exchange content of shared_ptr objects (function template )</p></li><li><p><a href="http://www.cplusplus.com/reference/memory/shared_ptr/operators/" target="_blank" rel="noopener"><strong>relational operators</strong></a></p><p>Relational operators ==, !=, &lt;, &lt;=, &gt;, &gt;= (function template )</p></li><li><p>[<strong>ostream operator&lt;&lt;</strong>](<a href="http://www.cplusplus.com/reference/memory/shared_ptr/operator" target="_blank" rel="noopener">http://www.cplusplus.com/reference/memory/shared_ptr/operator</a>&lt;</p><p>Insert into output stream (function template )</p></li></ul><ul><li><p><a href="http://www.cplusplus.com/reference/memory/make_shared/" target="_blank" rel="noopener"><strong>make_shared</strong></a></p><p>Make shared_ptr (function template )</p></li><li><p><a href="http://www.cplusplus.com/reference/memory/allocate_shared/" target="_blank" rel="noopener"><strong>allocate_shared</strong></a></p><p>Allocate shared_ptr (function template )</p></li><li><p><a href="http://www.cplusplus.com/reference/memory/static_pointer_cast/" target="_blank" rel="noopener"><strong>static_pointer_cast</strong></a></p><p>Static cast of shared_ptr (function template )</p></li><li><p><a href="http://www.cplusplus.com/reference/memory/dynamic_pointer_cast/" target="_blank" rel="noopener"><strong>dynamic_pointer_cast</strong></a></p><p>Dynamic cast of shared_ptr (function template )</p></li><li><p><a href="http://www.cplusplus.com/reference/memory/const_pointer_cast/" target="_blank" rel="noopener"><strong>const_pointer_cast</strong></a></p><p>Const cast of shared_ptr (function template )</p></li><li><p><a href="http://www.cplusplus.com/reference/memory/get_deleter/" target="_blank" rel="noopener"><strong>get_deleter</strong></a></p><p>Get deleter from shared_ptr (function template )</p></li></ul><h3 id="多线程问题"><a href="#多线程问题" class="headerlink" title="多线程问题"></a>多线程问题</h3><p>shared_ptr的线程安全的定义在boost的文档中有明确的说明：</p><ul><li><p>一个shared_ptr对象可以被多个线程同时read</p></li><li><p>两个shared_ptr对象，指向同一个raw指针，两个线程分别write这两个shared_ptr对象，是安全的。包括析构。</p></li><li><p>多个线程如果要对同一个shared_ptr对象读写，是线程不安全的</p></li></ul><p>也就是说，唯一需要注意的就是：多个线程中对同一个shared_ptr对象读写时需要加锁。但是即使是加锁也有技巧。比较好的方式是：</p><h2 id="std-weak-ptr"><a href="#std-weak-ptr" class="headerlink" title="std::weak_ptr"></a>std::weak_ptr</h2><p>引入是为了解决 std::share_ptr 的链接环问题。</p><h2 id="std-unique-ptr"><a href="#std-unique-ptr" class="headerlink" title="std::unique_ptr"></a>std::unique_ptr</h2><p><a href="https://msdn.microsoft.com/zh-cn/library/ee410601.aspx" target="_blank" rel="noopener">unique_ptr</a> 不共享它的指针。它无法复制到其他 unique_ptr，无法通过值传递到函数，也无法用于需要副本的任何标准模板库 (STL) 算法。只能移动</p><p>手册</p><ol><li><a href="http://www.cplusplus.com/reference/memory/shared_ptr/" target="_blank" rel="noopener">http://www.cplusplus.com/reference/memory/shared_ptr/</a></li><li><a href="http://c.biancheng.net/view/430.html" target="_blank" rel="noopener">http://c.biancheng.net/view/430.html</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文的目标是掌握清楚 智能指针 shared_ptr 和weak_ptr  涉及到的概念和使用。&lt;/p&gt;
&lt;h2 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h2&gt;&lt;h3 id=&quot;RAII-Reso
      
    
    </summary>
    
    
      <category term="C++基础系列" scheme="https://frank2019.github.io/categories/C-%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="C++" scheme="https://frank2019.github.io/tags/C/"/>
    
      <category term="智能指针" scheme="https://frank2019.github.io/tags/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/"/>
    
      <category term="shared_ptr" scheme="https://frank2019.github.io/tags/shared-ptr/"/>
    
  </entry>
  
  <entry>
    <title>AndroidCamera2概述</title>
    <link href="https://frank2019.github.io/2020/03/04/2_Camera2%E6%A6%82%E8%BF%B0/"/>
    <id>https://frank2019.github.io/2020/03/04/2_Camera2%E6%A6%82%E8%BF%B0/</id>
    <published>2020-03-04T00:31:15.342Z</published>
    <updated>2020-03-04T00:49:59.186Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0、引言"><a href="#0、引言" class="headerlink" title="0、引言"></a>0、引言</h2><ul><li><p>从 Android 5.0 开始，Google 引入了一套全新的相机框架 Camera2（android.hardware.camera2）</p></li><li><p>并废弃了旧的相机框架 Camera1（android.hardware.Camera）</p></li></ul><h2 id="1、Pipeline"><a href="#1、Pipeline" class="headerlink" title="1、Pipeline"></a>1、Pipeline</h2><p>Camera2 的 API 模型被设计成一个 Pipeline（管道），它按顺序处理每一帧的请求并返回请求结果给客户端。下面这张来自官方的图展示了 Pipeline 的工作流程，</p><p><img src="/2020/03/04/2_Camera2%E6%A6%82%E8%BF%B0/1.png" alt></p><p>为了解释上面的示意图，假设我们想要同时拍摄两张不同尺寸的图片，并且在拍摄的过程中闪光灯必须亮起来。整个拍摄流程如下：</p><ol><li>创建一个用于从 Pipeline 获取图片的 CaptureRequest。</li><li>修改 CaptureRequest 的闪光灯配置，让闪光灯在拍照过程中亮起来。</li><li>创建两个不同尺寸的 Surface 用于接收图片数据，并且将它们添加到 CaptureRequest 中。</li><li>发送配置好的 CaptureRequest 到 Pipeline 中等待它返回拍照结果。</li></ol><p>一个新的 CaptureRequest 会被放入一个被称作 Pending Request Queue 的队列中等待被执行，当 In-Flight Capture Queue 队列空闲的时候就会从 Pending Request Queue 获取若干个待处理的 CaptureRequest，并且根据每一个 CaptureRequest 的配置进行 Capture 操作。最后我们从不同尺寸的 Surface 中获取图片数据并且还会得到一个包含了很多与本次拍照相关的信息的 CaptureResult，流程结束。</p><h2 id="2、Supported-Hardware-Level"><a href="#2、Supported-Hardware-Level" class="headerlink" title="2、Supported Hardware Level"></a>2、Supported Hardware Level</h2><p>相机功能的强大与否和硬件息息相关，不同厂商对 Camera2 的支持程度也不同，所以 Camera2 定义了一个叫做 Supported Hardware Level 的重要概念，其作用是将不同设备上的 Camera2 根据功能的支持情况划分成多个不同级别以便开发者能够大概了解当前设备上 Camera2 的支持情况。截止到 Android P 为止，从低到高一共有 LEGACY、LIMITED、FULL 和 LEVEL_3 四个级别：</p><ol><li><strong>LEGACY</strong>：向后兼容的级别，处于该级别的设备意味着它只支持 Camera1 的功能，不具备任何 Camera2 高级特性。</li><li><strong>LIMITED</strong>：除了支持 Camera1 的基础功能之外，还支持部分 Camera2 高级特性的级别。</li><li><strong>FULL</strong>：支持所有 Camera2 的高级特性。</li><li><strong>LEVEL_3</strong>：新增更多 Camera2 高级特性，例如 YUV 数据的后处理等。</li></ol><h2 id="3、Capture"><a href="#3、Capture" class="headerlink" title="3、Capture"></a>3、Capture</h2><p>相机的所有操作和参数配置最终都是服务于图像捕获，例如对焦是为了让某一个区域的图像更加清晰，调节曝光补偿是为了调节图像的亮度。因此，在 Camera2 里面所有的相机操作和参数配置都被抽象成 Capture（捕获），所以不要简单的把 Capture 直接理解成是拍照，因为 Capture 操作可能仅仅是为了让预览画面更清晰而进行对焦而已。如果你熟悉 Camera1，那你可能会问 <code>setFlashMode()</code> 在哪？<code>setFocusMode()</code> 在哪？<code>takePicture()</code> 在哪？告诉你，它们都是通过 Capture 来实现的。</p><p>Capture 从执行方式上又被细分为【单次模式】、【多次模式】和【重复模式】三种，我们来一一解释下：</p><ul><li><strong>单次模式（One-shot）</strong>：指的是只执行一次的 Capture 操作，例如设置闪光灯模式、对焦模式和拍一张照片等。多个一次性模式的 Capture 会进入队列按顺序执行。</li><li><strong>多次模式（Burst）</strong>：指的是连续多次执行指定的 Capture 操作，该模式和多次执行单次模式的最大区别是连续多次 Capture 期间不允许插入其他任何 Capture 操作，例如连续拍摄 100 张照片，在拍摄这 100 张照片期间任何新的 Capture 请求都会排队等待，直到拍完 100 张照片。多组多次模式的 Capture 会进入队列按顺序执行。</li><li><strong>重复模式（Repeating）</strong>：指的是不断重复执行指定的 Capture 操作，当有其他模式的 Capture 提交时会暂停该模式，转而执行其他被模式的 Capture，当其他模式的 Capture 执行完毕后又会自动恢复继续执行该模式的 Capture，例如显示预览画面就是不断 Capture 获取每一帧画面。该模式的 Capture 是全局唯一的，也就是新提交的重复模式 Capture 会覆盖旧的重复模式 Capture。</li></ul><h2 id="4、CameraManager"><a href="#4、CameraManager" class="headerlink" title="4、CameraManager"></a>4、CameraManager</h2><p>CameraManager 是一个负责查询和建立相机连接的系统服务，它的功能不多，这里列出几个 CameraManager 的关键功能：</p><ol><li>将相机信息封装到 CameraCharacteristics 中，并提获取 CameraCharacteristics 实例的方式。</li><li>根据指定的相机 ID 连接相机设备。</li><li>提供将闪光灯设置成手电筒模式的快捷方式。</li></ol><h2 id="5、CameraCharacteristics"><a href="#5、CameraCharacteristics" class="headerlink" title="5、CameraCharacteristics"></a>5、CameraCharacteristics</h2><p>CameraCharacteristics 是一个只读的相机信息提供者，其内部携带大量的相机信息，包括</p><ul><li>代表相机朝向的 <code>LENS_FACING</code>；</li><li>判断闪光灯是否可用的 <code>FLASH_INFO_AVAILABLE</code>；</li><li>获取所有可用 AE 模式的 <code>CONTROL_AE_AVAILABLE_MODES</code> 等等。</li></ul><p>如果你对 Camera1 比较熟悉，那么 CameraCharacteristics 有点像 Camera1 的 <code>Camera.CameraInfo</code> 或者 <code>Camera.Parameters</code>。</p><h2 id="6、CameraDevice"><a href="#6、CameraDevice" class="headerlink" title="6、CameraDevice"></a>6、CameraDevice</h2><p>CameraDevice 代表当前连接的相机设备，它的职责有以下四个：</p><ol><li>根据指定的参数创建 CameraCaptureSession。</li><li>根据指定的模板创建 CaptureRequest。</li><li>关闭相机设备。</li><li>监听相机设备的状态，例如断开连接、开启成功和开启失败等。</li></ol><p>熟悉 Camera1 的人可能会说 CameraDevice 就是 Camera1 的 Camera 类，实则不是，Camera 类几乎负责了所有相机的操作，而 CameraDevice 的功能则十分的单一，就是只负责建立相机连接的事务，而更加细化的相机操作则交给了稍后会介绍的 CameraCaptureSession。</p><h2 id="7、Surface"><a href="#7、Surface" class="headerlink" title="7、Surface"></a>7、Surface</h2><p>Surface 是一块用于填充图像数据的内存空间，例如你可以使用 SurfaceView 的 Surface 接收每一帧预览数据用于显示预览画面，也可以使用 ImageReader 的 Surface 接收 JPEG 或 YUV 数据。每一个 Surface 都可以有自己的尺寸和数据格式，你可以从 CameraCharacteristics 获取某一个数据格式支持的尺寸列表。</p><h2 id="8、CameraCaptureSession"><a href="#8、CameraCaptureSession" class="headerlink" title="8、CameraCaptureSession"></a>8、CameraCaptureSession</h2><p>CameraCaptureSession 实际上就是配置了目标 Surface 的 Pipeline 实例，我们在使用相机功能之前必须先创建 CameraCaptureSession 实例。一个 CameraDevice 一次只能开启一个 CameraCaptureSession，绝大部分的相机操作都是通过向 CameraCaptureSession 提交一个 Capture 请求实现的，例如拍照、连拍、设置闪光灯模式、触摸对焦、显示预览画面等等。</p><h2 id="9、CaptureRequest"><a href="#9、CaptureRequest" class="headerlink" title="9、CaptureRequest"></a>9、CaptureRequest</h2><p>CaptureRequest 是向 CameraCaptureSession 提交 Capture 请求时的信息载体，其内部包括了本次 Capture 的参数配置和接收图像数据的 Surface。CaptureRequest 可以配置的信息非常多，包括图像格式、图像分辨率、传感器控制、闪光灯控制、3A 控制等等，可以说绝大部分的相机参数都是通过 CaptureRequest 配置的。值得注意的是每一个 CaptureRequest 表示一帧画面的操作，这意味着你可以精确控制每一帧的 Capture 操作。</p><h2 id="10、CaptureResult"><a href="#10、CaptureResult" class="headerlink" title="10、CaptureResult"></a>10、CaptureResult</h2><p>CaptureResult 是每一次 Capture 操作的结果，里面包括了很多状态信息，包括闪光灯状态、对焦状态、时间戳等等。例如你可以在拍照完成的时候，通过 CaptureResult 获取本次拍照时的对焦状态和时间戳。需要注意的是，CaptureResult 并不包含任何图像数据，前面我们在介绍 Surface 的时候说了，图像数据都是从 Surface 获取的。</p><h2 id="11、一些只有-Camera2-才支持的高级特性"><a href="#11、一些只有-Camera2-才支持的高级特性" class="headerlink" title="11、一些只有 Camera2 才支持的高级特性"></a>11、一些只有 Camera2 才支持的高级特性</h2><p>如果要我给出强有力的理由解释为什么要使用 Camera2，那么通过 Camera2 提供的高级特性可以构建出更加高质量的相机应用程序应该是最佳理由了。</p><ol><li><strong>在开启相机之前检查相机信息</strong><br> 出于某些原因，你可能需要先检查相机信息再决定是否开启相机，例如检查闪光灯是否可用。在 Caemra1 上，你无法在开机相机之前检查详细的相机信息，因为这些信息都是通过一个已经开启的相机实例提供的。在 Camera2 上，我们有了和相机实例完全剥离的 CameraCharacteristics 实例专门提供相机信息，所以我们可以在不开启相机的前提下检查几乎所有的相机信息。</li><li><strong>在不开启预览的情况下拍照</strong><br> 在 Camera1 上，开启预览是一个很重要的环节，因为只有在开启预览之后才能进行拍照，因此即使显示预览画面与实际业务需求相违背的时候，你也不得不开启预览。而 Camera2 则不强制要求你必须先开启预览才能拍照。</li><li><strong>一次拍摄多张不同格式和尺寸的图片</strong><br> 在 Camera1 上，一次只能拍摄一张图片，更不同谈多张不同格式和尺寸的图片了。而 Camera2 则支持一次拍摄多张图片，甚至是多张格式和尺寸都不同的图片。例如你可以同时拍摄一张 1440x1080 的 JPEG 图片和一张全尺寸的 RAW 图片。</li><li><strong>控制曝光时间</strong><br> 在暗环境下拍照的时候，如果能够适当延长曝光时间，就可以让图像画面的亮度得到提高。在 Camera2 上，你可以在规定的曝光时长范围内配置拍照的曝光时间，从而实现拍摄长曝光图片，你甚至可以延长每一帧预览画面的曝光时间让整个预览画面在暗环境下也能保证一定的亮度。而在 Camera1 上你只能 YY 一下。</li><li><strong>连拍</strong><br> 连拍 30 张图片这样的功能在 Camera2 出现之前恐怕只有系统相机才能做到了（通过 OpenGL 截取预览画面的做法除外），也可能是出于这个原因，市面上的第三方相机无一例外都不支持连拍。有了 Camera2，你完全可以让你的相机应用程序支持连拍功能，甚至是连续拍 30 张使用不同曝光时间的图片。</li><li><strong>灵活的 3A 控制</strong><br> 3A（AF、AE、AWB）的控制在 Camera2 上得到了最大化的放权，应用层可以根据业务需求灵活配置 3A 流程并且实时获取 3A 状态，而 Camera1 在 3A 的控制和监控方面提供的接口则要少了很多。例如你可以在拍照前进行 AE 操作，并且监听本这次拍照是否点亮闪光灯。</li></ol><h2 id="12、一些从-Camera1-迁移到-Camera2-的建议"><a href="#12、一些从-Camera1-迁移到-Camera2-的建议" class="headerlink" title="12、一些从 Camera1 迁移到 Camera2 的建议"></a>12、一些从 Camera1 迁移到 Camera2 的建议</h2><p>如果你熟悉 Camera1，并且打算从 Camera1 迁移到 Camera2 的话，希望以下几个建议可以对你起到帮助：</p><ol><li>Camera1 严格区分了预览和拍照两个流程，而 Camera2 则把这两个流程都抽象成了 Capture 行为，只不过一个是不断重复的 Capture，一个是一次性的 Capture 而已，所以建议你不要带着过多的 Camera1 思维使用 Camera2，避免因为思维上的束缚而无法充分利用 Camera2 灵活的 API。</li><li>如同 Camera1 一样，Camera2 的一些 API 调用也会耗时，所以建议你使用独立的线程执行所有的相机操作，尽量避免直接在主线程调用 Camera2 的 API，HandlerThread 是一个不错的选择。</li><li>Camera2 所有的相机操作都可以注册相关的回调接口，然后在不同的回调方法里写业务逻辑，这可能会让你的代码因为不够线性而错综复杂，建议你可以尝试使用子线程的阻塞方式来尽可能地保证代码的线性执行（熟悉 Dart 的人一定很喜欢它的 async 和 await 操作）。例如在子线程阻塞等待 CaptureResult，然后继续执行后续的操作，而不是将代码拆分到到 <code>CaptureCallback.onCaptureCompleted()</code> 方法里。</li><li>你可以认为 Camera1 是 Camera2 的一个子集，也就是说 Camera1 能做的事情 Camera2 一定能做，反过来则不一定行得通。</li><li>如果你的应用程序需要同时兼容 Camera1 和 Camera2，个人建议分开维护，因为 Camera1 蹩脚的 API 设计很可能让 Camera2 灵活的 API 无法得到充分的发挥，另外将两个设计上完全不兼容的东西搅和在一起带来的痛苦可能远大于其带来便利性，多写一些冗余的代码也许还更开心。</li><li>官方说 Camera2 的性能会更好，这句话听听就好，起码在较早期的一些机器上运行 Camera2 的性能并没有比 Camera1 好。</li><li>当设备的 Supported Hardware Level 低于 FULL 的时候，建议还是使用 Camera1，因为 FULL 级别以下的 Camera2 能提供的功能几乎和 Camera1 一样，所以倒不如选择更加稳定的 Camera1。</li></ol><h2 id="13、结束语"><a href="#13、结束语" class="headerlink" title="13、结束语"></a>13、结束语</h2><p>本章到此结束，主要是介绍了 Camera2 的一些基础概念，让大家能够基本了解 Camera2 的工作流程和基础概念，并且知道使用 Camera2 能够做些什么。如果你对 Camera2 还是感到很陌生，不要紧，后续的教程会带领大家逐步深入了解 Camera2。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ol><li><a href="https://www.jianshu.com/p/9a2e66916fcb" target="_blank" rel="noopener">Android Camera2 教程 · 第一章 · 概览</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;0、引言&quot;&gt;&lt;a href=&quot;#0、引言&quot; class=&quot;headerlink&quot; title=&quot;0、引言&quot;&gt;&lt;/a&gt;0、引言&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;从 Android 5.0 开始，Google 引入了一套全新的相机框架 Camera2（android.
      
    
    </summary>
    
    
      <category term="AndroidCamera" scheme="https://frank2019.github.io/categories/AndroidCamera/"/>
    
    
      <category term="Android" scheme="https://frank2019.github.io/tags/Android/"/>
    
      <category term="Camera" scheme="https://frank2019.github.io/tags/Camera/"/>
    
      <category term="Camera2" scheme="https://frank2019.github.io/tags/Camera2/"/>
    
  </entry>
  
  <entry>
    <title>AndroidCamera架构</title>
    <link href="https://frank2019.github.io/2020/03/04/1_camera_%E6%9E%B6%E6%9E%84/"/>
    <id>https://frank2019.github.io/2020/03/04/1_camera_%E6%9E%B6%E6%9E%84/</id>
    <published>2020-03-04T00:31:15.335Z</published>
    <updated>2020-03-04T00:50:08.837Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Camera架构"><a href="#Camera架构" class="headerlink" title="Camera架构"></a>Camera架构</h2><p>Camera的架构与Android系统的整体架构保持一致，如下图所示:</p><p><img src="/2020/03/04/1_camera_%E6%9E%B6%E6%9E%84/20170821154908066.dib" alt></p><h2 id="分层"><a href="#分层" class="headerlink" title="分层"></a>分层</h2><ul><li><p>Framework：<code>frameworks/base/core/java/android/hardware/Camera.java</code></p></li><li><p>Android Runtime：<code>frameworks/base/core/jni/android_hardware_Camera.cpp</code>  </p></li><li><p>C/C++ Libraries：</p><ul><li>Client：<pre><code>frameworks/av/camera/CameraBase.cppframeworks/av/camera/Camera.cppframeworks/av/camera/ICamera.cppframeworks/av/camera/aidl/android/hardware/ICamera.aidlframeworks/av/camera/aidl/android/hardware/ICameraClient.aidl</code></pre></li><li>Server：<pre><code>frameworks/av/camera/cameraserver/main_cameraserver.cppframeworks/av/services/camera/libcameraservice/CameraService.cppframeworks/av/services/camera/libcameraservice/api1/CameraClient.cppframeworks/av/camera/aidl/android/hardware/ICameraService.aidl</code></pre></li></ul></li><li><p>HAL：</p><ul><li>HAL 1：<pre><code>frameworks/av/services/camera/libcameraservice/device1/CameraHardwareInterface.h</code></pre></li><li>HAL 3：(主要学习了 HAL 1 的机制，HAL 3 以后再补充）<pre><code>frameworks/av/services/camera/libcameraservice/device3/***</code></pre></li></ul></li></ul><h2 id="C-S架构"><a href="#C-S架构" class="headerlink" title="C/S架构"></a>C/S架构</h2><p>Android Camera 框架是 一个 client/service 的架构。</p><ul><li>service进程</li></ul><p>属于服务端，由native c/c++代码实现,主要负责 通过HAL层和linux kernel中的camera driver交互。搜集camera driver 传递过来的数据，响应client端的请求</p><ul><li>client进程</li></ul><p>属于客户端，由java和native c/c++ 代码实现。可以看成应用程序。调用关系大致如下：</p><p>app –&gt;camera2 api framework –&gt;  android_hardware_camera.cpp –&gt;libcamera_client.so</p><h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><p>本系列的目标是从应用层 -&gt; framework -&gt;HAL –&gt;driver 详细的分析学习Android Camera系统。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Camera架构&quot;&gt;&lt;a href=&quot;#Camera架构&quot; class=&quot;headerlink&quot; title=&quot;Camera架构&quot;&gt;&lt;/a&gt;Camera架构&lt;/h2&gt;&lt;p&gt;Camera的架构与Android系统的整体架构保持一致，如下图所示:&lt;/p&gt;
&lt;p&gt;&lt;im
      
    
    </summary>
    
    
      <category term="AndroidCamera" scheme="https://frank2019.github.io/categories/AndroidCamera/"/>
    
    
      <category term="Android" scheme="https://frank2019.github.io/tags/Android/"/>
    
      <category term="Camera" scheme="https://frank2019.github.io/tags/Camera/"/>
    
      <category term="架构" scheme="https://frank2019.github.io/tags/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>hexo及next配置进阶-定制化博客</title>
    <link href="https://frank2019.github.io/2020/03/01/hexo_3_hexo%E5%8F%8Anext%E9%85%8D%E7%BD%AE%E8%BF%9B%E9%98%B6/"/>
    <id>https://frank2019.github.io/2020/03/01/hexo_3_hexo%E5%8F%8Anext%E9%85%8D%E7%BD%AE%E8%BF%9B%E9%98%B6/</id>
    <published>2020-03-01T02:15:13.509Z</published>
    <updated>2020-03-01T08:47:51.128Z</updated>
    
    <content type="html"><![CDATA[<h2 id="博客名字体的配置"><a href="#博客名字体的配置" class="headerlink" title="博客名字体的配置"></a>博客名字体的配置</h2><p>目标是把博客的名字的字体更改。</p><p>这部分的设置可以在theme的配置种修改。</p><p>themes\next_config.yml</p><p>如下，我将字体改为华文隶书。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># Font settings for site title (.site-title).</span></span><br><span class="line"><span class="attr">title:</span></span><br><span class="line">  <span class="attr">external:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">family:</span> <span class="string">华文隶书</span> <span class="comment">#Roboto Slab</span></span><br><span class="line">  <span class="attr">size:</span> <span class="number">4</span></span><br></pre></td></tr></table></figure><p>依次类推，比如文章标题 正文等等的字体和大小的设置也可以在这部分配置种实现。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;博客名字体的配置&quot;&gt;&lt;a href=&quot;#博客名字体的配置&quot; class=&quot;headerlink&quot; title=&quot;博客名字体的配置&quot;&gt;&lt;/a&gt;博客名字体的配置&lt;/h2&gt;&lt;p&gt;目标是把博客的名字的字体更改。&lt;/p&gt;
&lt;p&gt;这部分的设置可以在theme的配置种修改。&lt;/
      
    
    </summary>
    
    
      <category term="hexo" scheme="https://frank2019.github.io/categories/hexo/"/>
    
    
  </entry>
  
  <entry>
    <title>关于自我提升方法论</title>
    <link href="https://frank2019.github.io/2020/02/29/001.%E8%87%AA%E6%88%91%E6%8F%90%E5%8D%87%E6%96%B9%E6%B3%95%E8%AE%BA/"/>
    <id>https://frank2019.github.io/2020/02/29/001.%E8%87%AA%E6%88%91%E6%8F%90%E5%8D%87%E6%96%B9%E6%B3%95%E8%AE%BA/</id>
    <published>2020-02-29T02:20:50.145Z</published>
    <updated>2020-02-29T02:48:06.494Z</updated>
    
    <content type="html"><![CDATA[<p>在这个日新月异的时代，似乎每天如果不有点进步似乎都不好意思出门见人，</p><p>也更不好意思，谈理想和人生。</p><p>汤铭有云:苟日新,日日新,又日新!</p><p>你我或许是稚子顽童，青年才俊 亦或许是老骥伏枥，均可意气风发，志在千里。</p><p>但千里之行，终须始于足下，</p><p>万丈高楼也需凭地基而起，</p><p>像大海一样的事业也是靠江河小流聚势而成。</p><p>《大学》里说： 物有本末，事有终始，知所先后，则近道矣。</p><p>本系列的目标即是研究，学习之道，自我提升之方法论。</p><p>欢迎一起参禅悟道，勇攀高峰！</p><p>我是晓光，希望能和你相伴。公众号：猫爪在线</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在这个日新月异的时代，似乎每天如果不有点进步似乎都不好意思出门见人，&lt;/p&gt;
&lt;p&gt;也更不好意思，谈理想和人生。&lt;/p&gt;
&lt;p&gt;汤铭有云:苟日新,日日新,又日新!&lt;/p&gt;
&lt;p&gt;你我或许是稚子顽童，青年才俊 亦或许是老骥伏枥，均可意气风发，志在千里。&lt;/p&gt;
&lt;p&gt;但千里之
      
    
    </summary>
    
    
      <category term="自我提升方法论" scheme="https://frank2019.github.io/categories/%E8%87%AA%E6%88%91%E6%8F%90%E5%8D%87%E6%96%B9%E6%B3%95%E8%AE%BA/"/>
    
    
  </entry>
  
  <entry>
    <title>写博客的好处</title>
    <link href="https://frank2019.github.io/2020/02/28/hexo_1_%E5%86%99%E5%8D%9A%E5%AE%A2%E7%9A%84%E5%A5%BD%E5%A4%84/"/>
    <id>https://frank2019.github.io/2020/02/28/hexo_1_%E5%86%99%E5%8D%9A%E5%AE%A2%E7%9A%84%E5%A5%BD%E5%A4%84/</id>
    <published>2020-02-28T00:27:54.330Z</published>
    <updated>2020-03-01T08:44:22.167Z</updated>
    
    <content type="html"><![CDATA[<h3 id><a href="#" class="headerlink" title></a></h3><p>古人说:  格物、致知、诚意、正心 ， 修身、齐家、治国、平天下 。</p><p>古人又说：   立德、立功、立言 ，三不朽。  写博客也算立言的开始吧。</p><p>我觉得这是金玉良言啊。</p><p>那么咱们谈谈，我觉得写博客的好处具体有那些？</p><ol><li>教学相长</li><li>加深对技术和概念的理解；</li><li>提高思维能力，和逻辑能力；</li><li>提高沟通能力，每一篇文章都是一次自我沟通的开始。</li><li>方便查阅以后用的到；</li><li>可以看到多年之前的文章/想法/当时对技术的理解。</li><li>获取阅读量，得到认可，提高知名度；</li><li>结交志同道合的人，结伴前行；</li><li>提高写作水平,文案水平；</li><li>为自己的人生留下只言片语；</li><li>碎片化学习；</li></ol><p>如果你对独立博客感兴趣，可以加入群聊。一起交流</p><p> 独立博客爱好群QQ群: 1071329826 </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id&gt;&lt;a href=&quot;#&quot; class=&quot;headerlink&quot; title&gt;&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;古人说:  格物、致知、诚意、正心 ， 修身、齐家、治国、平天下 。&lt;/p&gt;
&lt;p&gt;古人又说：   立德、立功、立言 ，三不朽。  写博客也算立言的开始吧。&lt;/p&gt;
&lt;
      
    
    </summary>
    
    
      <category term="hexo" scheme="https://frank2019.github.io/categories/hexo/"/>
    
    
  </entry>
  
  <entry>
    <title>基于hexo免费搭建个人独立博客</title>
    <link href="https://frank2019.github.io/2020/02/27/hexo_2_%E5%9F%BA%E4%BA%8Ehexo%E5%85%8D%E8%B4%B9%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E7%8B%AC%E7%AB%8B%E5%8D%9A%E5%AE%A2/"/>
    <id>https://frank2019.github.io/2020/02/27/hexo_2_%E5%9F%BA%E4%BA%8Ehexo%E5%85%8D%E8%B4%B9%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E7%8B%AC%E7%AB%8B%E5%8D%9A%E5%AE%A2/</id>
    <published>2020-02-27T13:32:25.820Z</published>
    <updated>2020-03-02T00:12:16.641Z</updated>
    
    <content type="html"><![CDATA[<h3 id="本系列目标"><a href="#本系列目标" class="headerlink" title="本系列目标"></a>本系列目标</h3><p>免费搭建一个静态独立博客。</p><p>关键词： 免费，静态独立博客。</p><h3 id="GitHub创建个人仓库"><a href="#GitHub创建个人仓库" class="headerlink" title="GitHub创建个人仓库"></a>GitHub创建个人仓库</h3><p>免费的问题是通过GitHub解决的，Github有提供相关的免费服务，我们基于此可以构建免费的静态独立博客。</p><ol><li>登录到 GitHub ，</li><li>如果没有 GitHub 帐号，请使用你的邮箱注册 GitHub 帐号：<a href="https://github.com/join?source=header-home" target="_blank" rel="noopener">https://github.com/join?source=header-home</a></li><li>登录成功之后，点击 GitHub 中的 New repository 创建新仓库，仓库名应该为：<strong>用户名</strong>.github.io 。这里<strong>用户名</strong>使用你的 GitHub 帐号名称代替，这是固定写法。 </li></ol><h3 id="使用git配置key免密码访问"><a href="#使用git配置key免密码访问" class="headerlink" title="使用git配置key免密码访问"></a>使用git配置key免密码访问</h3><p>Git 是目前世界上最先进的分布式版本控制系统（没有之一）。这是使用 Git 的目的是将我们的网站部署到服务器（GitHub）上面去。</p><h4 id="安装Git"><a href="#安装Git" class="headerlink" title="安装Git"></a>安装Git</h4><p>推荐: <a href="https://gitforwindows.org/" target="_blank" rel="noopener">https://gitforwindows.org/</a></p><p> 安装好 Git 后，只需要进行下面的配置即可 </p><h4 id="配置信息"><a href="#配置信息" class="headerlink" title="配置信息"></a>配置信息</h4><p>在终端进行操作，设置 user.name 和 user.email 配置信息，我这里设置为全局。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name <span class="string">"你的GitHub用户名"</span></span><br><span class="line">git config --global user.email <span class="string">"你的GitHub注册邮箱"</span></span><br></pre></td></tr></table></figure><h4 id="生成密钥"><a href="#生成密钥" class="headerlink" title="生成密钥"></a>生成密钥</h4><p>通过注册的邮箱生成 ssh 密钥文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C <span class="string">"你的GitHub注册邮箱"</span></span><br></pre></td></tr></table></figure><p> 然后直接三个回车即可，默认不需要设置密码。最后得到了两个文件：<code>id_rsa</code>和<code>id_rsa.pub</code>。 </p><p> 打开 <code>id_rsa.pub 文件</code>，将里面的内容全部复制。 </p><h4 id="配置到GitHub"><a href="#配置到GitHub" class="headerlink" title="配置到GitHub"></a>配置到GitHub</h4><p>登录自己的Github，选择 setting -&gt; SSH and GPG keys </p><p>在SSH keys 项中 点击 New SSH key 按钮</p><p>Title可以自己定义， key中 拷贝入刚才在<code>id_rsa.pub 文件</code> 拷贝的内容</p><p>点击Add SSH key 配置完成。</p><h4 id="测试GitHub-SSH"><a href="#测试GitHub-SSH" class="headerlink" title="测试GitHub SSH"></a>测试GitHub SSH</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure><p>显示如下代表OK</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">λ ssh -T git@github.com</span><br><span class="line">Hi frank2019! You&#39;ve successfully authenticated, but GitHub does not provide shell access</span><br></pre></td></tr></table></figure><h3 id="Hexo安装"><a href="#Hexo安装" class="headerlink" title="Hexo安装"></a>Hexo安装</h3><h4 id="安装Node-js"><a href="#安装Node-js" class="headerlink" title="安装Node.js"></a>安装Node.js</h4><p>Hexo 基于 Node.js，因此需要先安装 Node.js；</p><p>你可以在这里进行对应电脑版本的下载：<a href="https://nodejs.org/en/download/" target="_blank" rel="noopener">https://nodejs.org/en/download/</a></p><h4 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h4><p>Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。</p><p>所有必备的应用程序安装完成后，即可使用 npm 安装 Hexo。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure><h3 id="Hexo使用"><a href="#Hexo使用" class="headerlink" title="Hexo使用"></a>Hexo使用</h3><p>安装好 Hexo 后，马上就能使用了。首先初始化博客，输入：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo <span class="keyword">init</span> myBlog</span><br></pre></td></tr></table></figure><p> 接下来，进入文件夹 <code>myBlog</code>,输入 </p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo s</span><br></pre></td></tr></table></figure><p>此时，在本地的你的博客已经运行起来，可以在浏览器中查看</p><p> 然后，打开浏览器输入地址： </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">localhost:4000</span><br></pre></td></tr></table></figure><p>执行到这里事实上博客就已经搭建好了，接下来就是去完善它。</p><p>注意：下面的命令都是在 <code>myBlog</code>文件里进行操作的。</p><h3 id="添加文章"><a href="#添加文章" class="headerlink" title="添加文章"></a>添加文章</h3><h4 id="1、直接导入文章"><a href="#1、直接导入文章" class="headerlink" title="1、直接导入文章"></a>1、直接导入文章</h4><p>你可以将你平时写的文章直接导入到 <code>_posts</code>  文件夹里，注意文章类型得是 <code>md</code>格式。</p><h4 id="2、写新文章"><a href="#2、写新文章" class="headerlink" title="2、写新文章"></a>2、写新文章</h4><p>你可以执行下列命令来创建一篇新文章。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new [layout] &lt;title&gt;</span><br></pre></td></tr></table></figure><h4 id="3、生成网页"><a href="#3、生成网页" class="headerlink" title="3、生成网页"></a>3、生成网页</h4><p>使用 Hexo 生成静态文件快速而且简单。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo generate</span><br><span class="line">//简写 hexo g</span><br></pre></td></tr></table></figure><h3 id="启动服务预览文章"><a href="#启动服务预览文章" class="headerlink" title="启动服务预览文章"></a>启动服务预览文章</h3><p> 输入以下命令以启动服务器，你的网站会在 <code>http://localhost:4000</code> 下启动。在服务器启动期间，Hexo 会监视文件变动并自动更新，无须重启服务器。 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo server</span><br></pre></td></tr></table></figure><p> 如果你想要更改端口，或是在执行时遇到了 <code>EADDRINUSE</code> 错误，可以在执行时使用 <code>-p</code> 选项指定其他端口，如下： </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server -p 5000</span><br></pre></td></tr></table></figure><h3 id="小总结"><a href="#小总结" class="headerlink" title="小总结"></a>小总结</h3><p>1、hexo init  [folder]       初始化本地文件夹为hexo项目</p><p>2、hexo new “我的博客文章”   #新建文章</p><p>3、hexo generate         #生成网页</p><p>4、hexo server     #启动服务预览</p><h3 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h3><p>Hexo 提供了快速方便的一键部署功能，只需一条命令就能将网站部署到服务器上。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p> 在开始之前，必须先在 <code>_config.yml</code> 中修改参数，一个正确的部署配置中至少要有 <code>type</code> 参数，例如： </p><p> 在<code>_config.yml</code>中进行修改。 </p><p>修改其中的deploy 为自己的内容。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Extensions</span></span><br><span class="line"><span class="comment">## Plugins: https://hexo.io/plugins/</span></span><br><span class="line"><span class="comment">## Themes: https://hexo.io/themes/</span></span><br><span class="line">theme: landscape</span><br><span class="line"></span><br><span class="line"><span class="comment"># Deployment</span></span><br><span class="line"><span class="comment">## Docs: https://hexo.io/docs/deployment.html</span></span><br><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: https://github.com/frank2019/frank2019.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure><p>这一步的目的是将 Hexo 与 GitHub 进行关联。</p><p>配置好后通过</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo d</span><br></pre></td></tr></table></figure><p> 命令，稍等片刻，网站就已经部署好了，可以在浏览器输入<code>你的GitHub名称.github.io</code>，这样一个免费的博客就已经搭建好了。 </p><p>我的博客是</p><p><a href="https://frank2019.github.io/">https://frank2019.github.io/</a></p><h3 id="Hexo-主题"><a href="#Hexo-主题" class="headerlink" title="Hexo 主题"></a>Hexo 主题</h3><p>hexo 默认的主题可能显得有点呆板，你可以在 <a href="https://hexo.io/themes/index.html进行主题的挑选更换。将下好的主题安放在`themes`文件夹内，同时在`_config.yml`中进行主题修改就好了。" target="_blank" rel="noopener">https://hexo.io/themes/index.html进行主题的挑选更换。将下好的主题安放在`themes`文件夹内，同时在`_config.yml`中进行主题修改就好了。</a></p><p> 一般大佬们提供的主题都会提供文档说明，按照说明进行简单的设置就能拥有一个酷炫的页面了。 </p><p>推荐链接：</p><p><a href="https://www.hexothe.me/" target="_blank" rel="noopener">排名前 10 的 Hexo 主题</a></p><h3 id="出错处理"><a href="#出错处理" class="headerlink" title="出错处理"></a>出错处理</h3><h4 id="ERROR-Deployer-not-found-git"><a href="#ERROR-Deployer-not-found-git" class="headerlink" title="ERROR Deployer not found: git"></a>ERROR Deployer not found: git</h4><p> hexo d<br> ERROR Deployer not found: git </p><p>执行以下命令即可</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install --save hexo-deployer-git</span><br></pre></td></tr></table></figure><h4 id="Package-cheerio-is-not-installed"><a href="#Package-cheerio-is-not-installed" class="headerlink" title="Package cheerio is not installed."></a>Package cheerio is not installed.</h4><p>INFO  Checking dependencies<br>ERROR Package cheerio is not installed.<br>ERROR Please install the missing dependencies from the root directory of your Hexo site.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ npm install cheerio</span><br><span class="line">npm WARN npm npm does not support Node.js v12.16.1</span><br><span class="line">npm WARN npm You should probably upgrade to a newer version of node as we</span><br><span class="line">npm WARN npm can<span class="string">'t make any promises that npm will work with this version.</span></span><br><span class="line"><span class="string">npm WARN npm Supported releases of Node.js are the latest release of 6, 8, 9, 10, 11.</span></span><br><span class="line"><span class="string">npm WARN npm You can find the latest version at https://nodejs.org/</span></span><br><span class="line"><span class="string">npm WARN optional SKIPPING OPTIONAL DEPENDENCY: fsevents@2.1.2 (node_modules\fsevents):</span></span><br><span class="line"><span class="string">npm WARN notsup SKIPPING OPTIONAL DEPENDENCY: Unsupported platform for fsevents@2.1.2: wanted &#123;"os":"darwin","arch":"any"&#125; (current: &#123;"os":"win32","arch":"x64"&#125;)</span></span><br><span class="line"><span class="string">npm WARN optional SKIPPING OPTIONAL DEPENDENCY: fsevents@1.2.11 (node_modules\nunjucks\node_modules\fsevents):</span></span><br><span class="line"><span class="string">npm WARN notsup SKIPPING OPTIONAL DEPENDENCY: Unsupported platform for fsevents@1.2.11: wanted &#123;"os":"darwin","arch":"any"&#125; (current: &#123;"os":"win32","arch":"x64"&#125;)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">+ cheerio@1.0.0-rc.3</span></span><br><span class="line"><span class="string">added 16 packages from 47 contributors in 5.886s</span></span><br></pre></td></tr></table></figure><hr><p>动手试一下吧！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;本系列目标&quot;&gt;&lt;a href=&quot;#本系列目标&quot; class=&quot;headerlink&quot; title=&quot;本系列目标&quot;&gt;&lt;/a&gt;本系列目标&lt;/h3&gt;&lt;p&gt;免费搭建一个静态独立博客。&lt;/p&gt;
&lt;p&gt;关键词： 免费，静态独立博客。&lt;/p&gt;
&lt;h3 id=&quot;GitHub创建个
      
    
    </summary>
    
    
      <category term="hexo" scheme="https://frank2019.github.io/categories/hexo/"/>
    
    
      <category term="hexo" scheme="https://frank2019.github.io/tags/hexo/"/>
    
      <category term="独立博客" scheme="https://frank2019.github.io/tags/%E7%8B%AC%E7%AB%8B%E5%8D%9A%E5%AE%A2/"/>
    
      <category term="next" scheme="https://frank2019.github.io/tags/next/"/>
    
  </entry>
  
  <entry>
    <title>我是谁?</title>
    <link href="https://frank2019.github.io/2020/02/27/who-am-I/"/>
    <id>https://frank2019.github.io/2020/02/27/who-am-I/</id>
    <published>2020-02-27T13:32:25.811Z</published>
    <updated>2020-03-02T00:14:30.955Z</updated>
    
    <content type="html"><![CDATA[<h3 id="我是谁"><a href="#我是谁" class="headerlink" title="我是谁?"></a>我是谁?</h3><p>很高兴大家来到这里，我是‘东胜神州’博客</p><ul><li><p>在这里我会坚持优质的内容</p></li><li><p>坚持价值投资 </p></li><li><p>坚持长期主义 </p></li><li><p>热爱美食 旅行 编程  参禅悟道</p></li><li><p>坚持成就你我的梦想 </p></li><li><p>坚持知行合一(实践类的话题坚持打磨出个不错的(或实习)产品，有所得)</p></li><li><p>如切如磋,如琢如磨</p></li></ul><p>欢迎大家多提宝贵意见！  十分感谢!</p><h3 id="交流学习"><a href="#交流学习" class="headerlink" title="交流学习"></a>交流学习</h3><ul><li>独立博客爱好群QQ群: 1071329826 </li></ul><h3 id="我可以为你做什么"><a href="#我可以为你做什么" class="headerlink" title="我可以为你做什么?"></a>我可以为你做什么?</h3><h3 id="欢迎合作"><a href="#欢迎合作" class="headerlink" title="欢迎合作"></a>欢迎合作</h3><p>开放包容 锐意进取 合作共赢!</p><p>有好的想法或创意欢迎加我！</p><p>我的公众号:  猫爪在线</p><p>Email: <a href="mailto:frank2019@yeah.net">frank2019@yeah.net</a></p><p>QQ:454052811</p><p><img src="/2020/02/27/who-am-I/le.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;我是谁&quot;&gt;&lt;a href=&quot;#我是谁&quot; class=&quot;headerlink&quot; title=&quot;我是谁?&quot;&gt;&lt;/a&gt;我是谁?&lt;/h3&gt;&lt;p&gt;很高兴大家来到这里，我是‘东胜神州’博客&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;在这里我会坚持优质的内容&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
      
    
    </summary>
    
    
      <category term="我是谁" scheme="https://frank2019.github.io/categories/%E6%88%91%E6%98%AF%E8%B0%81/"/>
    
    
      <category term="关于博客" scheme="https://frank2019.github.io/tags/%E5%85%B3%E4%BA%8E%E5%8D%9A%E5%AE%A2/"/>
    
      <category term="东胜神州" scheme="https://frank2019.github.io/tags/%E4%B8%9C%E8%83%9C%E7%A5%9E%E5%B7%9E/"/>
    
      <category term="我们的理念" scheme="https://frank2019.github.io/tags/%E6%88%91%E4%BB%AC%E7%9A%84%E7%90%86%E5%BF%B5/"/>
    
  </entry>
  
  <entry>
    <title>Dear ImGui library简介及入门</title>
    <link href="https://frank2019.github.io/2020/02/27/Dear%20ImGui%20library%E7%AE%80%E4%BB%8B%E5%8F%8A%E5%85%A5%E9%97%A8/"/>
    <id>https://frank2019.github.io/2020/02/27/Dear%20ImGui%20library%E7%AE%80%E4%BB%8B%E5%8F%8A%E5%85%A5%E9%97%A8/</id>
    <published>2020-02-27T13:32:25.785Z</published>
    <updated>2020-02-24T14:40:53.921Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Dear-ImGui-library-简介"><a href="#Dear-ImGui-library-简介" class="headerlink" title="Dear ImGui library  简介"></a>Dear ImGui library  简介</h2><p>作为开发人员，我们都面临着向程序引入图形界面的痛苦。传统的GUI库增加了一定程度的复杂性，如果您正在制作用于调试的工具，则可能不需要这些复杂性。在这里，我们提供了一个库，使创建记录器、配置文件器、调试器甚至整个游戏编辑器成为可能。这里介绍的整个示例可在Github上查阅。</p><h3 id="Dear-ImGui"><a href="#Dear-ImGui" class="headerlink" title="Dear ImGui?"></a>Dear ImGui?</h3><p><a href="https://github.com/ocornut/imgui" target="_blank" rel="noopener">Dear ImGui</a> 是一个令人惊叹的C++ UI 库，主要应用在游戏开发。该项目是开源软件，基于MIT license。Dear ImGui专注于简单性和生产力，使用的是<a href="https://caseymuratori.com/blog_0001" target="_blank" rel="noopener">Inmediate Mode GUI paradigm</a>。</p><p>即时模式GUI不同于传统的保留模式界面，因为小部件是在每个帧上创建和绘制的，而传统的方法是首先创建小部件并向其添加回调。这种模式的一些好处是您的UI“更接近”您的数据，并且它允许快速原型化。</p><p>Dear ImGui主要设计用于开发人员在内容创建和调试工具中使用..它是渲染器不可知论的方式，您必须提供工具来呈现数据，但它非常容易集成到您自己的代码中，因为它有多个绑定的不同窗口和事件处理库（如GLFW，SDL2和GLUT）和多个渲染器（如OpenGL，DirectX和Vulkan）。</p><p>Dear ImGui配备了许多小部件，如窗口、标签、输入框、进度条、按钮、滑块、树等。你可以在下面的图片中看到一些例子。</p><p>![](Dear ImGui library简介及入门/conan-imgui-widgets.gif)</p><h3 id="在应用中集成Dear-ImGui"><a href="#在应用中集成Dear-ImGui" class="headerlink" title="在应用中集成Dear ImGui"></a>在应用中集成Dear ImGui</h3><p>ImGui的典型用途是当您已经有了一个启用3D管道的应用程序，如内容创建或游戏开发工具，您希望在其中添加GUI。让我们看看在我们的应用程序中集成ImGui是多么容易。我们的示例应用程序使用OpenGL3呈现三角形。我们将使用GLFW管理窗口创建和事件处理。由于ImGui独立于渲染系统和平台，我们必须为我们的渲染系统引入一些绑定。幸运的是， Dear ImGui的设计中包含预先的绑定，比如我们在使用的Dear ImGui v1.69中我们包含以下头文件:</p><ul><li><a href="https://github.com/ocornut/imgui/blob/v1.69/examples/imgui_impl_opengl3.cpp" target="_blank" rel="noopener">imgui_impl_opengl3.cpp</a></li><li><a href="https://github.com/ocornut/imgui/blob/v1.69/examples/imgui_impl_opengl3.h" target="_blank" rel="noopener">imgui_impl_opengl3.h</a></li><li><a href="https://github.com/ocornut/imgui/blob/v1.69/examples/imgui_impl_glfw.cpp" target="_blank" rel="noopener">imgui_impl_glfw.cpp</a></li><li><a href="https://github.com/ocornut/imgui/blob/v1.69/examples/imgui_impl_glfw.h" target="_blank" rel="noopener">imgui_impl_glfw.h</a></li></ul><p>使此工作的最小代码在main.cpp中。首先，初始化用于呈现的窗口，然后必须初始化DearImGui上下文以及助手平台和Renderer绑定。如果您愿意，也可以更改渲染样式。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Setup Dear ImGui context</span></span><br><span class="line">IMGUI_CHECKVERSION();</span><br><span class="line">ImGui::CreateContext();</span><br><span class="line">ImGuiIO &amp;io = ImGui::GetIO();</span><br><span class="line"><span class="comment">// Setup Platform/Renderer bindings</span></span><br><span class="line">ImGui_ImplGlfw_InitForOpenGL(window, <span class="literal">true</span>);</span><br><span class="line">ImGui_ImplOpenGL3_Init(glsl_version);</span><br><span class="line"><span class="comment">// Setup Dear ImGui style</span></span><br><span class="line">ImGui::StyleColorsDark();</span><br></pre></td></tr></table></figure><p>然后，您进入主应用程序循环，在那里您可以清楚地看到与经典保留模式GUI的区别。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (!glfwWindowShouldClose(window))</span><br><span class="line">&#123;</span><br><span class="line">    glfwPollEvents();</span><br><span class="line">    glClearColor(<span class="number">0.45f</span>, <span class="number">0.55f</span>, <span class="number">0.60f</span>, <span class="number">1.00f</span>);</span><br><span class="line">    glClear(GL_COLOR_BUFFER_BIT);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// feed inputs to dear imgui, start new frame</span></span><br><span class="line">    ImGui_ImplOpenGL3_NewFrame();</span><br><span class="line">    ImGui_ImplGlfw_NewFrame();</span><br><span class="line">    ImGui::NewFrame();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// rendering our geometries</span></span><br><span class="line">    triangle_shader.use();</span><br><span class="line">    glBindVertexArray(vao);</span><br><span class="line">    glDrawElements(GL_TRIANGLES, <span class="number">3</span>, GL_UNSIGNED_INT, <span class="number">0</span>);</span><br><span class="line">    glBindVertexArray(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// render your GUI</span></span><br><span class="line">    ImGui::Begin(<span class="string">"Demo window"</span>);</span><br><span class="line">    ImGui::Button(<span class="string">"Hello!"</span>);</span><br><span class="line">    ImGui::End();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Render dear imgui into screen</span></span><br><span class="line">    ImGui::Render();</span><br><span class="line">    ImGui_ImplOpenGL3_RenderDrawData(ImGui::GetDrawData());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> display_w, display_h;</span><br><span class="line">    glfwGetFramebufferSize(window, &amp;display_w, &amp;display_h);</span><br><span class="line">    glViewport(<span class="number">0</span>, <span class="number">0</span>, display_w, display_h);</span><br><span class="line">    glfwSwapBuffers(window);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，当循环结束时，做一些清理。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ImGui_ImplOpenGL3_Shutdown();</span><br><span class="line">ImGui_ImplGlfw_Shutdown();</span><br><span class="line">ImGui::DestroyContext();</span><br></pre></td></tr></table></figure><p>所以，这就是我们得到的：</p><p><img src="/2020/02/27/Dear%20ImGui%20library%E7%AE%80%E4%BB%8B%E5%8F%8A%E5%85%A5%E9%97%A8/conan-imgui-hello-world.gif" alt></p><p>例如，让我们说，我们想要改变三角形的位置/方向和颜色。这就像调用一些滑块和选色器，并通过着色器将数据传递给三角形一样简单：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// render your GUI</span></span><br><span class="line">ImGui::Begin(<span class="string">"Triangle Position/Color"</span>);</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">float</span> rotation = <span class="number">0.0</span>;</span><br><span class="line">ImGui::SliderFloat(<span class="string">"rotation"</span>, &amp;rotation, <span class="number">0</span>, <span class="number">2</span> * PI);</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">float</span> translation[] = &#123;<span class="number">0.0</span>, <span class="number">0.0</span>&#125;;</span><br><span class="line">ImGui::SliderFloat2(<span class="string">"position"</span>, translation, <span class="number">-1.0</span>, <span class="number">1.0</span>);</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">float</span> color[<span class="number">4</span>] = &#123; <span class="number">1.0f</span>,<span class="number">1.0f</span>,<span class="number">1.0f</span>,<span class="number">1.0f</span> &#125;;</span><br><span class="line"><span class="comment">// pass the parameters to the shader</span></span><br><span class="line">triangle_shader.setUniform(<span class="string">"rotation"</span>, rotation);</span><br><span class="line">triangle_shader.setUniform(<span class="string">"translation"</span>, translation[<span class="number">0</span>], translation[<span class="number">1</span>]);</span><br><span class="line"><span class="comment">// color picker</span></span><br><span class="line">ImGui::ColorEdit3(<span class="string">"color"</span>, color);</span><br><span class="line"><span class="comment">// multiply triangle's color with this color</span></span><br><span class="line">triangle_shader.setUniform(<span class="string">"color"</span>, color[<span class="number">0</span>], color[<span class="number">1</span>], color[<span class="number">2</span>]);</span><br></pre></td></tr></table></figure><p><img src="/2020/02/27/Dear%20ImGui%20library%E7%AE%80%E4%BB%8B%E5%8F%8A%E5%85%A5%E9%97%A8/conan-imgui-triangle-rotate-color.gif" alt></p><p>还有一些基本的绘图工具。</p><p>![](Dear ImGui library简介及入门/conan-imgui-logo.png)</p><p>如果您想探索不同的库小部件和选项，最好的方法是调用ImGui：ShowDemoWindow（）并查看不同的示例。</p><h3 id="Setting-up-a-project-with-Conan"><a href="#Setting-up-a-project-with-Conan" class="headerlink" title="Setting up a project with Conan"></a>Setting up a project with Conan</h3><p>使用Connan建立一个使用ImGui的项目是一个几分钟的问题。这里显示的示例是使用Windows和Visual Studio2017，但在MacOS或Linux中非常相似。</p><p>如果您想尝试一下，可以从Connan示例中下载所有文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/conan-io/examples.git</span><br><span class="line"><span class="built_in">cd</span> examples/libraries/dear-imgui/basic</span><br></pre></td></tr></table></figure><p>首先，让我们检查CMake项目。它有GLFW和OpenGL3的绑定，还有两个文件来处理OpenGL阴影和文件读取。它还将复制每次重新编译应用程序时呈现三角形的着色器到工作目录。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.0</span>)</span><br><span class="line"><span class="keyword">project</span>(dear-imgui-conan CXX)</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>(CMAKE_PREFIX_PATH <span class="variable">$&#123;CMAKE_BINARY_DIR&#125;</span>)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_MODULE_PATH <span class="variable">$&#123;CMAKE_BINARY_DIR&#125;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># CONFIG option is important so that CMake doesnt search for modules into the default modules directory</span></span><br><span class="line"><span class="keyword">find_package</span>(imgui CONFIG)</span><br><span class="line"><span class="keyword">find_package</span>(glfw CONFIG)</span><br><span class="line"><span class="keyword">find_package</span>(glew CONFIG)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>( dear-imgui-conan </span><br><span class="line">                main.cpp </span><br><span class="line">                opengl_shader.cpp</span><br><span class="line">                file_manager.cpp</span><br><span class="line">                opengl_shader.h </span><br><span class="line">                file_manager.h </span><br><span class="line">                bindings/imgui_impl_glfw.cpp</span><br><span class="line">                bindings/imgui_impl_opengl3.cpp</span><br><span class="line">                bindings/imgui_impl_glfw.h</span><br><span class="line">                bindings/imgui_impl_opengl3.h </span><br><span class="line">                assets/simple-shader.vs</span><br><span class="line">                assets/simple-shader.fs )</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_custom_command</span>(<span class="keyword">TARGET</span> dear-imgui-conan</span><br><span class="line">    POST_BUILD</span><br><span class="line">    <span class="keyword">COMMAND</span> <span class="variable">$&#123;CMAKE_COMMAND&#125;</span> -E copy <span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/assets/simple-shader.vs <span class="variable">$&#123;PROJECT_BINARY_DIR&#125;</span></span><br><span class="line">    <span class="keyword">COMMAND</span> <span class="variable">$&#123;CMAKE_COMMAND&#125;</span> -E copy <span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/assets/simple-shader.fs <span class="variable">$&#123;PROJECT_BINARY_DIR&#125;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">target_compile_definitions</span>(dear-imgui-conan PUBLIC IMGUI_IMPL_OPENGL_LOADER_GLEW)</span><br><span class="line"></span><br><span class="line"><span class="keyword">target_link_libraries</span>(dear-imgui-conan imgui::imgui glfw::glfw glew::glew)</span><br></pre></td></tr></table></figure><p>我们还需要conanfile来声明它所依赖的库。除了GLF W库，我们还谈到了我们需要GLE W库来处理OpenGL函数加载。我们将使用cmake_multi为Debug和Release配置生成项目。还添加了一个导入部分，以下载GLFW和OpenGL3所需的绑定。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[requires]</span></span><br><span class="line">imgui/1.69@bincrafters/stable</span><br><span class="line">glfw/3.2.1@bincrafters/stable</span><br><span class="line">glew/2.1.0@bincrafters/stable</span><br><span class="line"></span><br><span class="line"><span class="section">[generators]</span></span><br><span class="line">cmake_find_package_multi</span><br><span class="line"></span><br><span class="line"><span class="section">[imports]</span></span><br><span class="line">./misc/bindings, imgui_impl_glfw.cpp -&gt; ../bindings</span><br><span class="line">./misc/bindings, imgui_impl_opengl3.cpp -&gt; ../bindings</span><br><span class="line">./misc/bindings, imgui_impl_glfw.h -&gt; ../bindings</span><br><span class="line">./misc/bindings, imgui_impl_opengl3.h -&gt; ../bindings</span><br></pre></td></tr></table></figure><p>现在让我们构建项目并运行应用程序。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> dear-imgui-conan-example</span><br><span class="line">mkdir build</span><br><span class="line"><span class="built_in">cd</span> build</span><br><span class="line">conan install .. -s build_type=Release</span><br><span class="line">conan install .. -s build_type=Debug</span><br><span class="line">cmake .. -G <span class="string">"Visual Studio 15 2017 Win64"</span></span><br><span class="line">cmake --build . --config Release</span><br><span class="line"><span class="built_in">cd</span> Release</span><br><span class="line">dear-imgui-conan</span><br></pre></td></tr></table></figure><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>Dear ImGui是一个强大的库，具有易于使用的API，它几乎无缝地集成到3D管道启用的应用程序中。它有很多小部件，可以成为一个很好的工具来制作调试软件，如分析器、记录器或任何类型的对象编辑器。此外，目前正在开发新的功能，如对接或多个视图端口。现在是时候体验Dear ImGUI了，并使它与您自己的代码交互了！</p><h3 id="参考连接"><a href="#参考连接" class="headerlink" title="参考连接"></a>参考连接</h3><ol><li><a href="https://eliasdaler.github.io/using-imgui-with-sfml-pt2/" target="_blank" rel="noopener">Using ImGui with modern C++ and STL for creating awesome game dev tools. Part 2. Some tips and tricks.</a></li><li><a href="https://github.com/ocornut/imgui" target="_blank" rel="noopener">https://github.com/ocornut/imgui</a></li><li><a href="https://blog.conan.io/2019/06/26/An-introduction-to-the-Dear-ImGui-library.html" target="_blank" rel="noopener">An introduction to the Dear ImGui library</a></li></ol><p><a href="https://conan.io/" target="_blank" rel="noopener">https://conan.io/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Dear-ImGui-library-简介&quot;&gt;&lt;a href=&quot;#Dear-ImGui-library-简介&quot; class=&quot;headerlink&quot; title=&quot;Dear ImGui library  简介&quot;&gt;&lt;/a&gt;Dear ImGui library  简介
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>费曼学习法-教学相长</title>
    <link href="https://frank2019.github.io/2020/02/27/001.%E8%B4%B9%E6%9B%BC%E5%AD%A6%E4%B9%A0%E6%B3%95-%E6%95%99%E5%AD%A6%E7%9B%B8%E9%95%BF/"/>
    <id>https://frank2019.github.io/2020/02/27/001.%E8%B4%B9%E6%9B%BC%E5%AD%A6%E4%B9%A0%E6%B3%95-%E6%95%99%E5%AD%A6%E7%9B%B8%E9%95%BF/</id>
    <published>2020-02-27T13:32:25.771Z</published>
    <updated>2020-03-01T13:21:14.633Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><blockquote><p><em>The person who says he knows what he thinks but cannot express it usually does not know what he thinks.</em></p><p>​                                                                                                               <em>— Mortimer Adler</em></p></blockquote><p>生硬翻译一下是：</p><blockquote><p> 心里感觉知道，但是不能准确的表达清楚，其实并非真正地知道。</p></blockquote><h2 id="费曼是谁？"><a href="#费曼是谁？" class="headerlink" title="费曼是谁？"></a>费曼是谁？</h2><p> <strong>理查德·费曼</strong></p><p>美国理论物理学家，量子电动力学创始人之一，纳米技术之父。</p><ul><li>他早年参与了“曼哈顿计划”，是推动世界第一颗原子弹研发的重要人物。</li><li>曾参与调查“挑战者号”航天飞机失事事件，并且在电视机前，向全美国人民用一个实验干净清晰的解释了失事原因。</li><li>他被认为是爱因斯坦之后最睿智的理论物理学家，也是第一位提出纳米概念的人。</li><li>1965年费曼因在量子电动力学方面的贡献获得诺贝尔物理学奖。</li><li>除了是个物理学家，费曼还是个作家、艺术家，擅长演奏手鼓，还擅长打开各类保险箱</li></ul><h2 id="费曼学习法"><a href="#费曼学习法" class="headerlink" title="费曼学习法"></a>费曼学习法</h2><p> 有一种学习方法被归于费曼的名下，虽然并没有事实证据是由费曼提出，但这个方法帮助了很多人快速学习一门技能。 </p><p>费曼学习法总共分四部（以下为众多版本之一）：</p><h3 id="1，Concept-（概念）"><a href="#1，Concept-（概念）" class="headerlink" title="1，Concept （概念）"></a>1，<strong>C</strong>oncept （概念）</h3><p>选择一个你要学习的<strong>概念</strong>，或者说是技能点;</p><h3 id="2，Teach-（教给别人）"><a href="#2，Teach-（教给别人）" class="headerlink" title="2，Teach （教给别人）"></a>2，<strong>T</strong>each （教给别人）</h3><p>想象把这个概念<strong>教</strong>给一个外行（或者八岁小孩）， 不使用任何高级的词汇或复杂的概念(因为使用它们时你很容易又陷入自欺的怪圈),使用小学生都可以听懂的语言。用这种方法讲授时，其实是在迫使自己更深刻的理解这个概念。同样重要的是，会发现自己在那些地方理解的还不够透彻。 </p><h3 id="3，Review-（评价）纠错学习"><a href="#3，Review-（评价）纠错学习" class="headerlink" title="3，Review （评价）纠错学习"></a>3，<strong>R</strong>eview （评价）纠错学习</h3><ul><li>在步骤二中，不可避免的遇到卡壳 或是难以解释的地方 甚至是遗漏重要的方面，</li><li>这其实是很有价值的反馈。</li><li>返回到原材料中，有针对性的学习相关的部分。<strong>评价</strong>你自己的教学并找到和原概念的差距。</li><li>然后合上原材料，重新回到步骤2.直到你完全通过步骤三。</li></ul><h3 id="4-Simplify-（简化）回顾和精简，总结"><a href="#4-Simplify-（简化）回顾和精简，总结" class="headerlink" title="4,Simplify （简化）回顾和精简，总结"></a>4,<strong>S</strong>implify （简化）回顾和精简，总结</h3><ul><li>经过前面的三步，你已经可以解释这个概念了；</li><li>现在回顾这些解释，确保你没有使用任何复杂的语言；</li><li>将这些解释大声读出来，如果听起来不够简洁，或者让人困惑，这就说明你在这些地方还可以进一步加深理解。你也可以尝试用常见事物和现象类比来解释。</li><li>最后，已经可以用最简洁清晰的语言解释清楚这个概念了。而这时，也表明你真的理解透彻这个概念的实质。</li><li>当使用这种方法时，慢慢透过这个方法的每一个步骤，精确地发现还有哪些内容没有理解。</li><li>这种学习方式非常高效，很少浪费时间。</li></ul><h3 id="5，找个实际的人试一下-可选"><a href="#5，找个实际的人试一下-可选" class="headerlink" title="5，找个实际的人试一下(可选)"></a>5，找个实际的人试一下(可选)</h3><h2 id="关于学习的话"><a href="#关于学习的话" class="headerlink" title="关于学习的话"></a>关于学习的话</h2><blockquote><p> 概念是一切知识架构的基石。所谓的“独立思考” ，对其最朴素的描述无非是：能够独立地、正确地使用正确的概念。 </p><p>​                                                                                             —-李笑来在《新生》一书                 </p></blockquote><blockquote><p>[With first principles thinking] you boil things down to the most fundamental truths … and then reason up from there.</p><p>[当你使用基本原则思维时] 你将事情追溯到最基本的真理…然后，从最基本的真理出发，向上逻辑推导。</p><p>​                                                                                                —马斯克</p></blockquote><blockquote><p> “<strong>你从头读，尽量往下读，直到你一窍不通时再从头开始，这样坚持往下读，直到你完全读懂为止</strong>”。 </p><p>–费曼</p></blockquote><blockquote><p> 董遇字季直,性质讷而好学。人有从学者,遇不肯教,而云“必当先读百遍！”言：“读书百遍，其义自见”。从学者云:“苦渴无日。”遇言“当以‘三余’。”或问“三余”之意,遇言“冬者岁之余,夜者日之余,阴雨者时之余也。 </p><p>​                                                                                                                                                            &lt;三国志&gt;</p></blockquote><blockquote><p>​     “是故学然后知不足，教然后知困。知不足然后能自反也，知困然后能自强也。故曰教学相长也。” </p><p>​                                                                                         《<a href="https://baike.baidu.com/item/礼记·学记" target="_blank" rel="noopener">礼记·学记</a>》 </p><p>PS:  这不就是费曼学习法吗？</p></blockquote><h2 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h2><p>如果你想更多的了解费曼的思想，不妨读读下面几本书。</p><ul><li><p>《别闹了，费曼先生》</p></li><li><p>《你干吗在乎别人怎么想？》</p></li><li><p>《发现的乐趣》</p></li><li><p>《费曼手札》</p></li><li><p>《费曼传》</p></li><li><p>《费曼物理学讲义》</p><p>2013年，BBC播出了一个费曼的记录片：The Fantastic Mr. Feynman，1个小时，也可以找来看看。 </p></li></ul><hr><p>公众号:  猫爪在线</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;The person who says he knows what he thinks but canno
      
    
    </summary>
    
    
      <category term="自我提升方法论" scheme="https://frank2019.github.io/categories/%E8%87%AA%E6%88%91%E6%8F%90%E5%8D%87%E6%96%B9%E6%B3%95%E8%AE%BA/"/>
    
    
      <category term="教学相长" scheme="https://frank2019.github.io/tags/%E6%95%99%E5%AD%A6%E7%9B%B8%E9%95%BF/"/>
    
      <category term="费曼" scheme="https://frank2019.github.io/tags/%E8%B4%B9%E6%9B%BC/"/>
    
      <category term="学习法" scheme="https://frank2019.github.io/tags/%E5%AD%A6%E4%B9%A0%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>教学相长</title>
    <link href="https://frank2019.github.io/2020/02/27/001.%E6%95%99%E5%AD%A6%E7%9B%B8%E9%95%BF/"/>
    <id>https://frank2019.github.io/2020/02/27/001.%E6%95%99%E5%AD%A6%E7%9B%B8%E9%95%BF/</id>
    <published>2020-02-27T13:32:25.745Z</published>
    <updated>2020-03-01T13:17:52.940Z</updated>
    
    <content type="html"><![CDATA[<p>两则典故，关于学习方法，关于教学相长。</p><h2 id="教学相长一"><a href="#教学相长一" class="headerlink" title="教学相长一"></a>教学相长一</h2><p><strong>原文</strong></p><p>虽有佳（嘉）肴，弗食，不知其旨也；虽有至道，弗学，不知其善也。是故学然后知不足，教然后知困。知不足，然后能自反也。知困，然后能自强也。故曰：教学相长也。兑命曰：“学学半。”其此之谓乎？</p><p><strong>译文</strong></p><p>即使有美味的菜肴，不吃，不会知道它的味道鲜美；即使有最好的道理，不学，不会知道它的高妙。因此，（通过）学习然后知道（自己）有不足的地方，（通过）教然后知道（自己）有困惑不解的地方。知道（自己）有不足的地方，然后（才）能够督促自己（进一步学习）；知道（自己）有困惑不解的地方，然后才能够自我奋发进取。所以说：教和学是互相促进、共同提高的。《兑命》说：教别人也是自己学习的一半。大概说的就是这个道理吧。</p><h2 id="教学相长二"><a href="#教学相长二" class="headerlink" title="教学相长二"></a>教学相长二</h2><p><strong>原文</strong></p><p>剑虽利，不厉不断；材虽美，不学不高。虽有嘉肴①，不尝不知其旨②；虽③有善道，不学不达其功。故学然后知不足，教然后知不究④。不足，故自愧而勉；不究，故尽师而熟。由此观之，则教学相长也。</p><p><strong>译文</strong></p><p>剑刃虽然锐利，不磨就不能斩断他物；人的资质虽然聪颖，不认真学习，就不能提高修养。虽然有美酒佳肴，不亲口品尝，就不能知道它们的味美；虽然有正确的道理，不努力学习，就不能通达它们的功用。所以说，通过学习，然后才会发现自己的不足；通过传授，然后才知道自己研究不深。发现自己的不足，就会心愧而努力学习，知道自己的研究不深，就会遍天下求师而弄透事理。从这些看来，传授与学习是相互促进的。</p><p>PS: 古代经典还是很有必要读的，不然死后不好意思见古人！</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ol><li><a href="https://www.jianshu.com/p/ec892fcc1261" target="_blank" rel="noopener">费曼读书法  </a></li><li><a href="https://baike.baidu.com/item/%E5%AD%A6%E8%AE%B0/1011104?fromtitle=%E7%A4%BC%E8%AE%B0%C2%B7%E5%AD%A6%E8%AE%B0&fromid=5912314" target="_blank" rel="noopener">礼记·学记</a></li><li><a href="https://baike.baidu.com/item/%E6%95%99%E5%AD%A6%E7%9B%B8%E9%95%BF/503225?fr=aladdin" target="_blank" rel="noopener">教学相长</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;两则典故，关于学习方法，关于教学相长。&lt;/p&gt;
&lt;h2 id=&quot;教学相长一&quot;&gt;&lt;a href=&quot;#教学相长一&quot; class=&quot;headerlink&quot; title=&quot;教学相长一&quot;&gt;&lt;/a&gt;教学相长一&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;原文&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;虽有佳（
      
    
    </summary>
    
    
      <category term="自我提升方法论" scheme="https://frank2019.github.io/categories/%E8%87%AA%E6%88%91%E6%8F%90%E5%8D%87%E6%96%B9%E6%B3%95%E8%AE%BA/"/>
    
    
      <category term="古文" scheme="https://frank2019.github.io/tags/%E5%8F%A4%E6%96%87/"/>
    
  </entry>
  
</feed>
