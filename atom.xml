<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>东胜神州</title>
  
  <subtitle>价值投资 长期主义 编程 美食 旅行 梦想 参禅 悟道</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://frank2019.github.io/"/>
  <updated>2020-03-23T00:00:27.742Z</updated>
  <id>https://frank2019.github.io/</id>
  
  <author>
    <name>晓光</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Python第2篇 python编程规范速查</title>
    <link href="https://frank2019.github.io/2020/03/23/python_02_%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83%E9%80%9F%E6%9F%A5/"/>
    <id>https://frank2019.github.io/2020/03/23/python_02_%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83%E9%80%9F%E6%9F%A5/</id>
    <published>2020-03-23T00:00:55.560Z</published>
    <updated>2020-03-23T00:00:27.742Z</updated>
    
    <content type="html"><![CDATA[<blockquote><ol><li>自律是成功的一半</li><li>好的编码规范是写好程序的一半。</li><li>软件工程及是在各种约束之中找到最佳的平衡的一门科学。</li></ol></blockquote><h2 id="1，分号"><a href="#1，分号" class="headerlink" title="1，分号"></a>1，分号</h2><ul><li><h5 id="不要在行尾加分号-也不要用分号将两条命令放在同一行"><a href="#不要在行尾加分号-也不要用分号将两条命令放在同一行" class="headerlink" title="不要在行尾加分号, 也不要用分号将两条命令放在同一行."></a>不要在行尾加分号, 也不要用分号将两条命令放在同一行.</h5></li><li><h5 id="基本不需要使用分号"><a href="#基本不需要使用分号" class="headerlink" title="基本不需要使用分号"></a>基本不需要使用分号</h5></li></ul><h2 id="2，行长度"><a href="#2，行长度" class="headerlink" title="2，行长度"></a>2，行长度</h2><ul><li><h5 id="每行不超过80个字符-长的导入语句和注释中的URL除外"><a href="#每行不超过80个字符-长的导入语句和注释中的URL除外" class="headerlink" title="每行不超过80个字符,长的导入语句和注释中的URL除外"></a>每行不超过80个字符,长的导入语句和注释中的URL除外</h5></li><li><h5 id="不要使用反斜杠连接行"><a href="#不要使用反斜杠连接行" class="headerlink" title="不要使用反斜杠连接行."></a>不要使用反斜杠连接行.</h5></li></ul><p>Python会将 <a href="http://docs.python.org/2/reference/lexical_analysis.html#implicit-line-joining" target="_blank" rel="noopener">圆括号, 中括号和花括号中的行隐式的连接起来</a> , 你可以利用这个特点. 如果需要, 你可以在表达式外围增加一对额外的圆括号.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> foo_bar(self, width, height, color=<span class="string">'black'</span>,design=<span class="literal">None</span>, x=<span class="string">'foo'</span>,</span><br><span class="line">        emphasis=<span class="literal">None</span>, highlight=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (width == <span class="number">0</span> <span class="keyword">and</span> height == <span class="number">0</span> <span class="keyword">and</span></span><br><span class="line">    color == <span class="string">'red'</span> <span class="keyword">and</span> emphasis == <span class="string">'strong'</span>):</span><br></pre></td></tr></table></figure><p>如果一个文本字符串在一行放不下, 可以使用圆括号来实现隐式行连接:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x = (<span class="string">'This will build a very long long '</span></span><br><span class="line">     <span class="string">'long long long long long long string'</span>)</span><br></pre></td></tr></table></figure><h2 id="3，括号"><a href="#3，括号" class="headerlink" title="3，括号"></a>3，括号</h2><ul><li><h5 id="宁缺毋滥的使用括号"><a href="#宁缺毋滥的使用括号" class="headerlink" title="宁缺毋滥的使用括号"></a>宁缺毋滥的使用括号</h5></li></ul><p>除非是用于实现行连接, 否则不要在返回语句或条件语句中使用括号. 不过在元组两边使用括号是可以的.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> foo:</span><br><span class="line">       bar()</span><br><span class="line">   <span class="keyword">while</span> x:</span><br><span class="line">       x = bar()</span><br><span class="line">   <span class="keyword">if</span> x <span class="keyword">and</span> y:</span><br><span class="line">       bar()</span><br><span class="line">   <span class="keyword">if</span> <span class="keyword">not</span> x:</span><br><span class="line">       bar()</span><br><span class="line">   <span class="keyword">return</span> foo</span><br><span class="line">   <span class="keyword">for</span> (x, y) <span class="keyword">in</span> dict.items(): ...</span><br></pre></td></tr></table></figure><h2 id="4，缩进"><a href="#4，缩进" class="headerlink" title="4，缩进"></a>4，缩进</h2><ul><li><h5 id="用4个空格来缩进代码"><a href="#用4个空格来缩进代码" class="headerlink" title="用4个空格来缩进代码"></a>用4个空格来缩进代码</h5></li></ul><p>绝对不要用tab, 也不要tab和空格混用. 对于行连接的情况, 你应该要么垂直对齐换行的元素(见 <a href="https://zh-google-styleguide.readthedocs.io/en/latest/google-python-styleguide/python_style_rules/#line-length" target="_blank" rel="noopener">行长度</a> 部分的示例), 或者使用4空格的悬挂式缩进(这时第一行不应该有参数):</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Yes:   <span class="comment"># Aligned with opening delimiter</span></span><br><span class="line">       foo = long_function_name(var_one, var_two,</span><br><span class="line">                                var_three, var_four)</span><br><span class="line"></span><br><span class="line">       <span class="comment"># Aligned with opening delimiter in a dictionary</span></span><br><span class="line">       foo = &#123;</span><br><span class="line">           long_dictionary_key: value1 +</span><br><span class="line">                                value2,</span><br><span class="line">           ...</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment"># 4-space hanging indent; nothing on first line</span></span><br><span class="line">       foo = long_function_name(</span><br><span class="line">           var_one, var_two, var_three,</span><br><span class="line">           var_four)</span><br><span class="line"></span><br><span class="line">       <span class="comment"># 4-space hanging indent in a dictionary</span></span><br><span class="line">       foo = &#123;</span><br><span class="line">           long_dictionary_key:</span><br><span class="line">               long_dictionary_value,</span><br><span class="line">           ...</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><h2 id="5，空行"><a href="#5，空行" class="headerlink" title="5，空行"></a>5，空行</h2><ul><li><h5 id="顶级定义之间空两行-方法定义之间空一行"><a href="#顶级定义之间空两行-方法定义之间空一行" class="headerlink" title="顶级定义之间空两行, 方法定义之间空一行"></a>顶级定义之间空两行, 方法定义之间空一行</h5></li></ul><p>顶级定义之间空两行, 比如函数或者类定义. 方法定义, 类定义与第一个方法之间, 都应该空一行. 函数或方法中, 某些地方要是你觉得合适, 就空一行.</p><h2 id="6，空格"><a href="#6，空格" class="headerlink" title="6，空格"></a>6，空格</h2><ul><li><h5 id="按照标准的排版规范来使用标点两边的空格"><a href="#按照标准的排版规范来使用标点两边的空格" class="headerlink" title="按照标准的排版规范来使用标点两边的空格"></a>按照标准的排版规范来使用标点两边的空格</h5></li></ul><ol><li>括号内不要有空格.</li><li>不要在逗号, 分号, 冒号前面加空格, 但应该在它们后面加(除了在行尾).</li><li>参数列表, 索引或切片的左括号前不应加空格.</li><li>在二元操作符两边都加上一个空格, 比如赋值(=), 比较(==, &lt;, &gt;, !=, &lt;&gt;, &lt;=, &gt;=, in, not in, is, is not), 布尔(and, or, not).  至于算术操作符两边的空格该如何使用, 需要你自己好好判断. 不过两侧务必要保持一致.</li><li>当’=’用于指示关键字参数或默认参数值时, 不要在其两侧使用空格.</li><li>不要用空格来垂直对齐多行间的标记, 因为这会成为维护的负担(适用于:, #, =等):</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Yes:</span><br><span class="line">     foo = <span class="number">1000</span>  <span class="comment"># comment</span></span><br><span class="line">     long_name = <span class="number">2</span>  <span class="comment"># comment that should not be aligned</span></span><br><span class="line"></span><br><span class="line">     dictionary = &#123;</span><br><span class="line">         <span class="string">"foo"</span>: <span class="number">1</span>,</span><br><span class="line">         <span class="string">"long_name"</span>: <span class="number">2</span>,</span><br><span class="line">         &#125;</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">No:</span><br><span class="line">     foo       = <span class="number">1000</span>  <span class="comment"># comment</span></span><br><span class="line">     long_name = <span class="number">2</span>     <span class="comment"># comment that should not be aligned</span></span><br><span class="line"></span><br><span class="line">     dictionary = &#123;</span><br><span class="line">         <span class="string">"foo"</span>      : <span class="number">1</span>,</span><br><span class="line">         <span class="string">"long_name"</span>: <span class="number">2</span>,</span><br><span class="line">         &#125;</span><br></pre></td></tr></table></figure><h2 id="7，Shebang"><a href="#7，Shebang" class="headerlink" title="7，Shebang"></a>7，Shebang</h2><ul><li><h5 id="大部分-py文件不必以-作为文件的开始-根据-PEP-394-程序的main文件应该以-usr-bin-python2或者-usr-bin-python3开始"><a href="#大部分-py文件不必以-作为文件的开始-根据-PEP-394-程序的main文件应该以-usr-bin-python2或者-usr-bin-python3开始" class="headerlink" title="大部分.py文件不必以#!作为文件的开始. 根据 PEP-394 , 程序的main文件应该以 #!/usr/bin/python2或者 #!/usr/bin/python3开始."></a>大部分.py文件不必以#!作为文件的开始. 根据 <a href="http://www.python.org/dev/peps/pep-0394/" target="_blank" rel="noopener">PEP-394</a> , 程序的main文件应该以 #!/usr/bin/python2或者 #!/usr/bin/python3开始.</h5></li></ul><p>#!先用于帮助内核找到Python解释器, 但是在导入模块时, 将会被忽略. 因此只有被直接执行的文件中才有必要加入#!.</p><h2 id="8，注释"><a href="#8，注释" class="headerlink" title="8，注释"></a>8，注释</h2><ul><li><h5 id="确保对模块-函数-方法和行内注释使用正确的风格"><a href="#确保对模块-函数-方法和行内注释使用正确的风格" class="headerlink" title="确保对模块, 函数, 方法和行内注释使用正确的风格"></a>确保对模块, 函数, 方法和行内注释使用正确的风格</h5></li></ul><h3 id="文档字符串"><a href="#文档字符串" class="headerlink" title="文档字符串"></a><strong>文档字符串</strong></h3><blockquote><p>Python有一种独一无二的的注释方式: 使用文档字符串. 文档字符串是包, 模块, 类或函数里的第一个语句.  这些字符串可以通过对象的<strong>doc</strong>成员被自动提取, 并且被pydoc所用. (你可以在你的模块上运行pydoc试一把, 看看它长什么样).  我们对文档字符串的惯例是使用三重双引号”“”( <a href="http://www.python.org/dev/peps/pep-0257/" target="_blank" rel="noopener">PEP-257</a> ). 一个文档字符串应该这样组织: 首先是一行以句号, 问号或惊叹号结尾的概述(或者该文档字符串单纯只有一行). 接着是一个空行. 接着是文档字符串剩下的部分, 它应该与文档字符串的第一行的第一个引号对齐. 下面有更多文档字符串的格式化规范.</p></blockquote><h3 id="模块"><a href="#模块" class="headerlink" title="模块"></a><strong>模块</strong></h3><blockquote><p>每个文件应该包含一个许可样板. 根据项目使用的许可(例如, Apache 2.0, BSD, LGPL, GPL), 选择合适的样板.</p></blockquote><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>所指的函数,包括函数, 方法, 以及生成器.</p><blockquote><p>一个函数必须要有文档字符串, 除非它满足以下条件:</p><ol><li>外部不可见</li><li>非常短小</li><li>简单明了</li></ol><p>文档字符串应该包含函数做什么, 以及输入和输出的详细描述. 通常, 不应该描述”怎么做”, 除非是一些复杂的算法.  文档字符串应该提供足够的信息, 当别人编写代码调用该函数时, 他不需要看一行代码, 只要看文档字符串就可以了. 对于复杂的代码,  在代码旁边加注释会比使用文档字符串更有意义.</p><p>关于函数的几个方面应该在特定的小节中进行描述记录， 这几个方面如下文所述. 每节应该以一个标题行开始. 标题行以冒号结尾. 除标题行外, 节的其他内容应被缩进2个空格.</p><ul><li>Args:</li></ul><p>列出每个参数的名字, 并在名字后使用一个冒号和一个空格, 分隔对该参数的描述.如果描述太长超过了单行80字符,使用2或者4个空格的悬挂缩进(与文件其他部分保持一致). 描述应该包括所需的类型和含义. 如果一个函数接受<em>foo(可变长度参数列表)或者*</em>bar (任意关键字参数), 应该详细列出<em>foo和*</em>bar.</p><ul><li>Returns: (或者 Yields: 用于生成器)</li></ul><p>描述返回值的类型和语义. 如果函数返回None, 这一部分可以省略.</p><ul><li>Raises:</li></ul><p>列出与接口有关的所有异常.</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fetch_bigtable_rows</span><span class="params">(big_table, keys, other_silly_variable=None)</span>:</span></span><br><span class="line">    <span class="string">"""Fetches rows from a Bigtable.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Retrieves rows pertaining to the given keys from the Table instance</span></span><br><span class="line"><span class="string">    represented by big_table.  Silly things may happen if</span></span><br><span class="line"><span class="string">    other_silly_variable is not None.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">        big_table: An open Bigtable Table instance.</span></span><br><span class="line"><span class="string">        keys: A sequence of strings representing the key of each table row</span></span><br><span class="line"><span class="string">            to fetch.</span></span><br><span class="line"><span class="string">        other_silly_variable: Another optional variable, that has a much</span></span><br><span class="line"><span class="string">            longer name than the other args, and which does nothing.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Returns:</span></span><br><span class="line"><span class="string">        A dict mapping keys to the corresponding table row data</span></span><br><span class="line"><span class="string">        fetched. Each row is represented as a tuple of strings. For</span></span><br><span class="line"><span class="string">        example:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        &#123;'Serak': ('Rigel VII', 'Preparer'),</span></span><br><span class="line"><span class="string">         'Zim': ('Irk', 'Invader'),</span></span><br><span class="line"><span class="string">         'Lrrr': ('Omicron Persei 8', 'Emperor')&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        If a key from the keys argument is missing from the dictionary,</span></span><br><span class="line"><span class="string">        then that row was not found in the table.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Raises:</span></span><br><span class="line"><span class="string">        IOError: An error occurred accessing the bigtable.Table object.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><p>应该在其定义下有一个用于描述该类的文档字符串. 如果你的类有公共属性(Attributes), 那么文档中应该有一个属性(Attributes)段. 并且应该遵守和函数参数相同的格式.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SampleClass</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">"""Summary of class here.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Longer class information....</span></span><br><span class="line"><span class="string">    Longer class information....</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Attributes:</span></span><br><span class="line"><span class="string">        likes_spam: A boolean indicating if we like SPAM or not.</span></span><br><span class="line"><span class="string">        eggs: An integer count of the eggs we have laid.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, likes_spam=False)</span>:</span></span><br><span class="line">        <span class="string">"""Inits SampleClass with blah."""</span></span><br><span class="line">        self.likes_spam = likes_spam</span><br><span class="line">        self.eggs = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">public_method</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""Performs operation blah."""</span></span><br></pre></td></tr></table></figure><h3 id="块注释和行注释"><a href="#块注释和行注释" class="headerlink" title="块注释和行注释"></a><strong>块注释和行注释</strong></h3><blockquote><p>最需要写注释的是代码中那些技巧性的部分. 如果你在下次 <a href="http://en.wikipedia.org/wiki/Code_review" target="_blank" rel="noopener">代码审查</a> 的时候必须解释一下, 那么你应该现在就给它写注释. 对于复杂的操作, 应该在其操作开始前写上若干行注释. 对于不是一目了然的代码, 应在其行尾添加注释.</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># We use a weighted dictionary search to find out where i is in</span></span><br><span class="line"><span class="comment"># the array.  We extrapolate position based on the largest num</span></span><br><span class="line"><span class="comment"># in the array and the array size and then do binary search to</span></span><br><span class="line"><span class="comment"># get the exact number.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> i &amp; (i<span class="number">-1</span>) == <span class="number">0</span>:        <span class="comment"># True if i is 0 or a power of 2.</span></span><br></pre></td></tr></table></figure><p>为了提高可读性, 注释应该至少离开代码2个空格.</p><p>另一方面, 绝不要描述代码. 假设阅读代码的人比你更懂Python, 他只是不知道你的代码要做什么.</p><h2 id="9，类"><a href="#9，类" class="headerlink" title="9，类"></a>9，类</h2><ul><li>如果一个类不继承自其它类, 就显式的从object继承. 嵌套类也一样</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Yes: <span class="class"><span class="keyword">class</span> <span class="title">SampleClass</span><span class="params">(object)</span>:</span></span><br><span class="line">         <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">     <span class="class"><span class="keyword">class</span> <span class="title">OuterClass</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">         <span class="class"><span class="keyword">class</span> <span class="title">InnerClass</span><span class="params">(object)</span>:</span></span><br><span class="line">             <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">     <span class="class"><span class="keyword">class</span> <span class="title">ChildClass</span><span class="params">(ParentClass)</span>:</span></span><br><span class="line">         <span class="string">"""Explicitly inherits from another class already."""</span></span><br></pre></td></tr></table></figure><h2 id="10，字符串"><a href="#10，字符串" class="headerlink" title="10，字符串"></a>10，字符串</h2><blockquote><p>即使参数都是字符串, 使用%操作符或者格式化方法格式化字符串. 不过也不能一概而论, 你需要在+和%之间好好判定.</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Yes: x &#x3D; a + b</span><br><span class="line">     x &#x3D; &#39;%s, %s!&#39; % (imperative, expletive)</span><br><span class="line">     x &#x3D; &#39;&#123;&#125;, &#123;&#125;!&#39;.format(imperative, expletive)</span><br><span class="line">     x &#x3D; &#39;name: %s; score: %d&#39; % (name, n)</span><br><span class="line">     x &#x3D; &#39;name: &#123;&#125;; score: &#123;&#125;&#39;.format(name, n)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">No: x &#x3D; &#39;%s%s&#39; % (a, b)  # use + in this case</span><br><span class="line">    x &#x3D; &#39;&#123;&#125;&#123;&#125;&#39;.format(a, b)  # use + in this case</span><br><span class="line">    x &#x3D; imperative + &#39;, &#39; + expletive + &#39;!&#39;</span><br><span class="line">    x &#x3D; &#39;name: &#39; + name + &#39;; score: &#39; + str(n)</span><br></pre></td></tr></table></figure><p>避免在循环中用+和+=操作符来累加字符串. 由于字符串是不可变的, 这样做会创建不必要的临时对象, 并且导致二次方而不是线性的运行时间. 作为替代方案, 你可以将每个子串加入列表, 然后在循环结束后用 <code>.join</code> 连接列表. (也可以将每个子串写入一个 <code>cStringIO.StringIO</code> 缓存中.)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Yes: items = [<span class="string">'&lt;table&gt;'</span>]</span><br><span class="line">     <span class="keyword">for</span> last_name, first_name <span class="keyword">in</span> employee_list:</span><br><span class="line">         items.append(<span class="string">'&lt;tr&gt;&lt;td&gt;%s, %s&lt;/td&gt;&lt;/tr&gt;'</span> % (last_name, first_name))</span><br><span class="line">     items.append(<span class="string">'&lt;/table&gt;'</span>)</span><br><span class="line">     employee_table = <span class="string">''</span>.join(items)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">No: employee_table = <span class="string">'&lt;table&gt;'</span></span><br><span class="line">    <span class="keyword">for</span> last_name, first_name <span class="keyword">in</span> employee_list:</span><br><span class="line">        employee_table += <span class="string">'&lt;tr&gt;&lt;td&gt;%s, %s&lt;/td&gt;&lt;/tr&gt;'</span> % (last_name, first_name)</span><br><span class="line">    employee_table += <span class="string">'&lt;/table&gt;'</span></span><br></pre></td></tr></table></figure><p>在同一个文件中, 保持使用字符串引号的一致性. 使用单引号’或者双引号”之一用以引用字符串, 并在同一文件中沿用. 在字符串内可以使用另外一种引号, 以避免在字符串中使用. PyLint已经加入了这一检查.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Yes:</span><br><span class="line">     Python(<span class="string">'Why are you hiding your eyes?'</span>)</span><br><span class="line">     Gollum(<span class="string">"I'm scared of lint errors."</span>)</span><br><span class="line">     Narrator(<span class="string">'"Good!" thought a happy Python reviewer.'</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">No:</span><br><span class="line">     Python(<span class="string">"Why are you hiding your eyes?"</span>)</span><br><span class="line">     Gollum(<span class="string">'The lint. It burns. It burns us.'</span>)</span><br><span class="line">     Gollum(<span class="string">"Always the great lint. Watching. Watching."</span>)</span><br></pre></td></tr></table></figure><p>文档字符串必须使用三重双引号”””</p><p> 多行字符串 通常用隐式行连接更清晰, 因为多行字符串与程序其他部分的缩进方式不一致.</p><h2 id="11，文件和sockets"><a href="#11，文件和sockets" class="headerlink" title="11，文件和sockets"></a>11，文件和sockets</h2><ul><li><h5 id="在文件和sockets结束时-显式的关闭它"><a href="#在文件和sockets结束时-显式的关闭它" class="headerlink" title="在文件和sockets结束时, 显式的关闭它."></a>在文件和sockets结束时, 显式的关闭它.</h5></li></ul><p>除文件外, sockets或其他类似文件的对象在没有必要的情况下打开, 会有许多副作用, 例如:</p><ol><li>它们可能会消耗有限的系统资源, 如文件描述符. 如果这些资源在使用后没有及时归还系统, 那么用于处理这些对象的代码会将资源消耗殆尽.</li><li>持有文件将会阻止对于文件的其他诸如移动、删除之类的操作.</li><li>仅仅是从逻辑上关闭文件和sockets, 那么它们仍然可能会被其共享的程序在无意中进行读或者写操作. 只有当它们真正被关闭后, 对于它们尝试进行读或者写操作将会抛出异常, 并使得问题快速显现出来.</li></ol><p>而且, 假设当文件对象析构时, 文件和sockets会自动关闭, 试图将文件对象的生命周期和文件的状态绑定在一起的想法, 都是不现实的. 因为有如下原因:</p><ol><li>没有任何方法可以确保运行环境会真正的执行文件的析构. 不同的Python实现采用不同的内存管理技术, 比如延时垃圾处理机制. 延时垃圾处理机制可能会导致对象生命周期被任意无限制的延长.</li><li>对于文件意外的引用,会导致对于文件的持有时间超出预期(比如对于异常的跟踪, 包含有全局变量等).</li></ol><p>推荐使用 <a href="http://docs.python.org/reference/compound_stmts.html#the-with-statement" target="_blank" rel="noopener">“with”语句</a> 以管理文件:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> open(<span class="string">"hello.txt"</span>) <span class="keyword">as</span> hello_file:</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> hello_file:</span><br><span class="line">        <span class="keyword">print</span> line</span><br></pre></td></tr></table></figure><p>对于不支持使用”with”语句的类似文件的对象,使用 <code>contextlib.closing()</code>:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> contextlib</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> contextlib.closing(urllib.urlopen(<span class="string">"http://www.python.org/"</span>)) <span class="keyword">as</span> front_page:</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> front_page:</span><br><span class="line">        <span class="keyword">print</span> line</span><br></pre></td></tr></table></figure><h2 id="12，TODO注释"><a href="#12，TODO注释" class="headerlink" title="12，TODO注释"></a>12，<code>TODO</code>注释</h2><ul><li><h5 id="为临时代码使用TODO注释-它是一种短期解决方案-不算完美-但够好了"><a href="#为临时代码使用TODO注释-它是一种短期解决方案-不算完美-但够好了" class="headerlink" title="为临时代码使用TODO注释, 它是一种短期解决方案. 不算完美, 但够好了."></a>为临时代码使用TODO注释, 它是一种短期解决方案. 不算完美, 但够好了.</h5></li></ul><p>TODO注释应该在所有开头处包含”TODO”字符串, 紧跟着是用括号括起来的你的名字, email地址或其它标识符. 然后是一个可选的冒号.<br>接着必须有一行注释, 解释要做什么. 主要目的是为了有一个统一的TODO格式, 这样添加注释的人就可以搜索到(并可以按需提供更多细节).<br>写了TODO注释并不保证写的人会亲自解决问题. 当你写了一个TODO, 请注上你的名字.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># TODO(kl@gmail.com): Use a "*" here for string repetition.</span></span><br><span class="line"><span class="comment"># TODO(Zeke) Change this to use relations.</span></span><br></pre></td></tr></table></figure><p>如果你的TODO是”将来做某事”的形式, 那么请确保你包含了一个指定的日期(“2009年11月解决”)或者一个特定的事件(“等到所有的客户都可以处理XML请求就移除这些代码”).</p><h2 id="13-导入格式"><a href="#13-导入格式" class="headerlink" title="13,导入格式"></a>13,导入格式</h2><ul><li><h5 id="每个导入应该独占一行"><a href="#每个导入应该独占一行" class="headerlink" title="每个导入应该独占一行"></a>每个导入应该独占一行</h5></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Yes: <span class="keyword">import</span> os</span><br><span class="line">     <span class="keyword">import</span> sys</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">No:  import os, sys</span><br></pre></td></tr></table></figure><p>导入总应该放在文件顶部, 位于模块注释和文档字符串之后, 模块全局变量和常量之前.  导入应该按照从最通用到最不通用的顺序分组:</p><ol><li>标准库导入</li><li>第三方库导入</li><li>应用程序指定导入</li></ol><p>每种分组中,  应该根据每个模块的完整包路径按字典序排序, 忽略大小写.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> foo</span><br><span class="line"><span class="keyword">from</span> foo <span class="keyword">import</span> bar</span><br><span class="line"><span class="keyword">from</span> foo.bar <span class="keyword">import</span> baz</span><br><span class="line"><span class="keyword">from</span> foo.bar <span class="keyword">import</span> Quux</span><br><span class="line"><span class="keyword">from</span> Foob <span class="keyword">import</span> ar</span><br></pre></td></tr></table></figure><h2 id="14-语句"><a href="#14-语句" class="headerlink" title="14,语句"></a>14,语句</h2><ul><li><h5 id="通常每个语句应该独占一行"><a href="#通常每个语句应该独占一行" class="headerlink" title="通常每个语句应该独占一行"></a>通常每个语句应该独占一行</h5></li></ul><p>不过, 如果测试结果与测试语句在一行放得下, 你也可以将它们放在同一行.  如果是if语句, 只有在没有else时才能这样做. 特别地, 绝不要对 <code>try/except</code> 这样做, 因为try和except不能放在同一行.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Do No like that!!</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> foo: bar(foo)</span><br><span class="line">  <span class="keyword">else</span>:   baz(foo)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span>:               bar(foo)</span><br><span class="line">  <span class="keyword">except</span> ValueError: baz(foo)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span>:</span><br><span class="line">      bar(foo)</span><br><span class="line">  <span class="keyword">except</span> ValueError: baz(foo)</span><br></pre></td></tr></table></figure><h2 id="15-访问控制"><a href="#15-访问控制" class="headerlink" title="15,访问控制"></a>15,访问控制</h2><blockquote><p>在Python中, 对于琐碎又不太重要的访问函数, 应该直接使用公有变量来取代它们, 这样可以避免额外的函数调用开销. 当添加更多功能时, 你可以用属性(property)来保持语法的一致性.</p></blockquote><p>另一方面, 如果访问更复杂, 或者变量的访问开销很显著, 那么你应该使用像 <code>get_foo()</code> 和 <code>set_foo()</code> 这样的函数调用. 如果之前的代码行为允许通过属性(property)访问 , 那么就不要将新的访问函数与属性绑定. 这样, 任何试图通过老方法访问变量的代码就没法运行, 使用者也就会意识到复杂性发生了变化.</p><h2 id="16-命名"><a href="#16-命名" class="headerlink" title="16,命名"></a>16,命名</h2><ul><li><h5 id="module-name-package-name-ClassName-method-name-ExceptionName-function-name-GLOBAL-VAR-NAME-instance-var-name-function-parameter-name-local-var-name"><a href="#module-name-package-name-ClassName-method-name-ExceptionName-function-name-GLOBAL-VAR-NAME-instance-var-name-function-parameter-name-local-var-name" class="headerlink" title="module_name, package_name, ClassName, method_name,  ExceptionName, function_name, GLOBAL_VAR_NAME, instance_var_name,  function_parameter_name, local_var_name."></a>module_name, package_name, ClassName, method_name,  ExceptionName, function_name, GLOBAL_VAR_NAME, instance_var_name,  function_parameter_name, local_var_name.</h5></li></ul><h4 id="应该避免的名称"><a href="#应该避免的名称" class="headerlink" title="应该避免的名称"></a>应该避免的名称</h4><blockquote><ol><li>单字符名称, 除了计数器和迭代器.</li><li>包/模块名中的连字符(-)</li><li>双下划线开头并结尾的名称(Python保留, 例如<code>__init__</code></li></ol></blockquote><h4 id="命名约定"><a href="#命名约定" class="headerlink" title="命名约定"></a>命名约定</h4><blockquote><ol><li>所谓”内部(Internal)”表示仅模块内可用, 或者, 在类内是保护或私有的.</li><li>用单下划线(_)开头表示模块变量或函数是protected的(使用from module import *时不会包含).</li><li>用双下划线(__)开头的实例变量或方法表示类内私有.</li><li>将相关的类和顶级函数放在同一个模块里. 不像Java, 没必要限制一个类一个模块.</li><li>对类名使用大写字母开头的单词(如CapWords, 即Pascal风格),  但是模块名应该用小写加下划线的方式(如lower_with_under.py).  尽管已经有很多现存的模块使用类似于CapWords.py这样的命名, 但现在已经不鼓励这样做, 因为如果模块名碰巧和类名一致, 这会让人困扰.</li></ol></blockquote><h4 id="Python之父Guido推荐的规范"><a href="#Python之父Guido推荐的规范" class="headerlink" title="Python之父Guido推荐的规范"></a>Python之父Guido推荐的规范</h4><table><thead><tr><th>Type</th><th>Public</th><th>Internal</th></tr></thead><tbody><tr><td>Modules</td><td>lower_with_under</td><td>_lower_with_under</td></tr><tr><td>Packages</td><td>lower_with_under</td><td></td></tr><tr><td>Classes</td><td>CapWords</td><td>_CapWords</td></tr><tr><td>Exceptions</td><td>CapWords</td><td></td></tr><tr><td>Functions</td><td>lower_with_under()</td><td>_lower_with_under()</td></tr><tr><td>Global/Class Constants</td><td>CAPS_WITH_UNDER</td><td>_CAPS_WITH_UNDER</td></tr><tr><td>Global/Class Variables</td><td>lower_with_under</td><td>_lower_with_under</td></tr><tr><td>Instance Variables</td><td>lower_with_under</td><td>_lower_with_under (protected) or __lower_with_under (private)</td></tr><tr><td>Method Names</td><td>lower_with_under()</td><td>_lower_with_under() (protected) or __lower_with_under() (private)</td></tr><tr><td>Function/Method Parameters</td><td>lower_with_under</td><td></td></tr><tr><td>Local Variables</td><td>lower_with_under</td><td></td></tr></tbody></table><h2 id="17-Main"><a href="#17-Main" class="headerlink" title="17,Main"></a>17,Main</h2><p>即使是一个打算被用作脚本的文件, 也应该是可导入的. 并且简单的导入不应该导致这个脚本的主功能(main functionality)被执行, 这是一种副作用. 主功能应该放在一个main()函数中.</p><p>在Python中, pydoc以及单元测试要求模块必须是可导入的. 你的代码应该在执行主程序前总是检查 <code>if __name__ == &#39;__main__&#39;</code> , 这样当模块被导入时主程序就不会被执行.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">      ...</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>所有的顶级代码在模块导入时都会被执行. 要小心不要去调用函数, 创建对象, 或者执行那些不应该在使用pydoc时执行的操作.</p><h2 id="19-参考链接"><a href="#19-参考链接" class="headerlink" title="19,参考链接"></a>19,参考链接</h2><ol><li><a href="https://zh-google-styleguide.readthedocs.io/en/latest/google-python-styleguide/python_style_rules/" target="_blank" rel="noopener">Python风格规范</a></li><li><a href="https://www.runoob.com/w3cnote/google-python-styleguide.html" target="_blank" rel="noopener">Python 编码规范(Google)</a></li><li><a href="https://blog.csdn.net/ratsniper/article/details/78954852" target="_blank" rel="noopener">Python PEP8 编码规范中文版</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;自律是成功的一半&lt;/li&gt;
&lt;li&gt;好的编码规范是写好程序的一半。&lt;/li&gt;
&lt;li&gt;软件工程及是在各种约束之中找到最佳的平衡的一门科学。&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;1，分号&quot;&gt;&lt;a href=&quot;
      
    
    </summary>
    
    
      <category term="python入门到进阶" scheme="https://frank2019.github.io/categories/python%E5%85%A5%E9%97%A8%E5%88%B0%E8%BF%9B%E9%98%B6/"/>
    
    
      <category term="python" scheme="https://frank2019.github.io/tags/python/"/>
    
      <category term="编程规范" scheme="https://frank2019.github.io/tags/%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/"/>
    
  </entry>
  
  <entry>
    <title>Python第一篇 pytest 5分钟入门</title>
    <link href="https://frank2019.github.io/2020/03/23/python_01_pytest5%E5%88%86%E9%92%9F%E5%85%A5%E9%97%A8/"/>
    <id>https://frank2019.github.io/2020/03/23/python_01_pytest5%E5%88%86%E9%92%9F%E5%85%A5%E9%97%A8/</id>
    <published>2020-03-22T23:51:47.849Z</published>
    <updated>2020-03-23T00:08:04.399Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p> 安徐正静</p></blockquote><h2 id="1、pytest-特点"><a href="#1、pytest-特点" class="headerlink" title="1、pytest 特点"></a>1、pytest 特点</h2><p>pytest是一个非常成熟的全功能的Python测试框架，主要有以下几个特点：</p><ul><li>简单灵活，容易上手</li><li>支持参数化</li><li>能够支持简单的单元测试和复杂的功能测试，还可以用来做selenium/appnium等自动化测试、接口自动化测试（pytest+requests）</li><li><code>pytest</code>具有丰富第三方插件，良好的自定义扩展</li><li>测试用例的skip和xfail处理</li><li>可以很好的和jenkins集成</li><li>report框架—-allure 也支持了pytest</li></ul><h2 id="2、支持插件"><a href="#2、支持插件" class="headerlink" title="2、支持插件"></a>2、支持插件</h2><p>完整的插件list，可以到下面这三个站点看看：</p><ol><li><p><a href="https://docs.pytest.org/en/latest/plugins.html" target="_blank" rel="noopener">https://docs.pytest.org/en/latest/plugins.html</a></p></li><li><p><a href="https://pypi.python.org" target="_blank" rel="noopener">https://pypi.python.org</a></p></li><li><p><a href="https://github.com/pytest-dev" target="_blank" rel="noopener">https://github.com/pytest-dev</a></p></li></ol><p>下面是一些出名的插件list:</p><ul><li>pytest-repeat: 可以多次运行测试用例，用来提高发现那些偶然错误的几率</li><li>pytest-xdist: 可以利用机器的多核，提升测试的速度</li><li>pytest-timeout: 可以为测试加入超时</li><li>pytest-instatfail: 在错误发生的时候，立即报告它</li><li>pytest-sugar: 整合了pytest-instatfail以及代码高亮，颜色字体…</li><li>pytest-emoji: 为测试报告加入了一些有趣的东西</li><li>pytest-html: 在测试完成后，会生成一份html报告文件</li><li>pytest-pycodestyle, pytest-pep8, pytest-flake8: 进行代码规范检查</li><li>pytest-rerunfailures（失败case重复执行）</li><li>pytest-selenium</li><li>pytest-django</li><li>pytest-flask    </li></ul><h2 id="3、安装"><a href="#3、安装" class="headerlink" title="3、安装"></a>3、安装</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install -U pytest</span><br></pre></td></tr></table></figure><p>验证安装的版本：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pytest --version</span><br></pre></td></tr></table></figure><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pytest</span><br><span class="line"></span><br><span class="line"><span class="comment"># content of test_sample.py</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x + <span class="number">1</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_answer</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">assert</span> func(<span class="number">3</span>) == <span class="number">5</span></span><br></pre></td></tr></table></figure><p>命令行切换到文件所在目录，执行测试（也可以直接在IDE中运行）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pytest  xxx.py</span><br></pre></td></tr></table></figure><p>当需要编写多个测试样例的时候，我们可以将其放到一个测试类当中，如</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestClass</span>:</span>  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_one</span><span class="params">(self)</span>:</span>  </span><br><span class="line">        x = <span class="string">"this"</span>  </span><br><span class="line">        <span class="keyword">assert</span> <span class="string">'h'</span> <span class="keyword">in</span> x  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_two</span><span class="params">(self)</span>:</span>  </span><br><span class="line">        x = <span class="string">"hello"</span>  </span><br><span class="line">        <span class="keyword">assert</span> hasattr(x, <span class="string">'check'</span>)</span><br></pre></td></tr></table></figure><h2 id="4、如何编写pytest测试样例"><a href="#4、如何编写pytest测试样例" class="headerlink" title="4、如何编写pytest测试样例"></a>4、<strong>如何编写pytest测试样例</strong></h2><p>规则：</p><ul><li>测试文件以test_开头（以_test结尾也可以）</li><li>测试类以Test开头，并且不能带有 <strong>init</strong> 方法</li><li>测试函数以test_开头</li><li>断言使用基本的assert即可</li></ul><h2 id="5、运行模式"><a href="#5、运行模式" class="headerlink" title="5、运行模式"></a>5、运行模式</h2><p>   Pytest的多种运行模式，让测试和调试变得更加得心应手，下面介绍5种常用的模式。在介绍之前需要提醒一句，运行pytest时会找当前目录及其子目录中的所有test_*.py 或 *_test.py格式的文件以及以test开头的方法或者class，不然就会提示找不到可以运行的case了。</p><h3 id="5-1、运行后生成测试报告"><a href="#5-1、运行后生成测试报告" class="headerlink" title="5.1、运行后生成测试报告"></a><strong>5.1</strong>、运行后生成测试报告</h3><p>运行后生成测试报告（htmlReport</p><p>安装pytest-html：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install -U pytest-html</span><br></pre></td></tr></table></figure><p>运行模式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pytest --html&#x3D;report.html</span><br></pre></td></tr></table></figure><p>报告效果：</p><p><img src="https:////upload-images.jianshu.io/upload_images/6536777-15708c4ed724a509.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000" alt="img"></p><p>在以上报告中可以清晰的看到测试结果和错误原因，定位问题很容易。</p><h3 id="5-2、运行指定的case"><a href="#5-2、运行指定的case" class="headerlink" title="5.2、运行指定的case"></a><strong>5.2、运行指定的case</strong></h3><p>  当我们写了较多的cases时，如果每次都要全部运行一遍，无疑是很浪费时间的，通过指定case来运行就很方便了。</p><p>例子代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestClassOne</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_one</span><span class="params">(self)</span>:</span></span><br><span class="line">        x = <span class="string">"this"</span></span><br><span class="line">        <span class="keyword">assert</span> <span class="string">'t'</span><span class="keyword">in</span> x</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_two</span><span class="params">(self)</span>:</span></span><br><span class="line">        x = <span class="string">"hello"</span></span><br><span class="line">        <span class="keyword">assert</span> hasattr(x, <span class="string">'check'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestClassTwo</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_one</span><span class="params">(self)</span>:</span></span><br><span class="line">        x = <span class="string">"iphone"</span></span><br><span class="line">        <span class="keyword">assert</span> <span class="string">'p'</span><span class="keyword">in</span> x</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_two</span><span class="params">(self)</span>:</span></span><br><span class="line">        x = <span class="string">"apple"</span></span><br><span class="line">        <span class="keyword">assert</span> hasattr(x, <span class="string">'check'</span>)</span><br></pre></td></tr></table></figure><p>运行模式：</p><p>模式1：直接运行test_se.py文件中的所有cases:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pytest test_se.py</span><br></pre></td></tr></table></figure><p>模式2：运行test_se.py文件中的TestClassOne这个class下的两个cases:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pytest test_se.py::TestClassOne</span><br></pre></td></tr></table></figure><p>模式3：运行test_se.py文件中的TestClassTwo这个class下的test_one:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pytest test_se.py::TestClassTwo::test_one</span><br></pre></td></tr></table></figure><blockquote><p>注意：定义class时，需要以T开头，不然pytest是不会去运行该class的。</p></blockquote><h3 id="5-3、多进程运行cases"><a href="#5-3、多进程运行cases" class="headerlink" title="5.3、多进程运行cases"></a>5.3、多进程运行cases</h3><p>  当cases量很多时，运行时间也会变的很长，如果想缩短脚本运行的时长，就可以用多进程来运行。</p><p>安装pytest-xdist：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install -U pytest-xdist</span><br></pre></td></tr></table></figure><p>运行模式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pytest test_se.py -n NUM</span><br></pre></td></tr></table></figure><p>其中NUM填写并发的进程数。</p><h3 id="5-4、重试运行cases"><a href="#5-4、重试运行cases" class="headerlink" title="5.4、重试运行cases"></a>5.4、重试运行cases</h3><p>  在做接口测试时，有事会遇到503或短时的网络波动，导致case运行失败，而这并非是我们期望的结果，此时可以就可以通过重试运行cases的方式来解决。</p><p>安装pytest-rerunfailures：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install -U pytest-rerunfailures</span><br></pre></td></tr></table></figure><p>运行模式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pytest test_se.py --reruns NUM</span><br></pre></td></tr></table></figure><p>NUM填写重试的次数。</p><h3 id="5-5、显示print内容"><a href="#5-5、显示print内容" class="headerlink" title="5.5、显示print内容"></a>5.5、显示print内容</h3><p>  在运行测试脚本时，为了调试或打印一些内容，我们会在代码中加一些print内容，但是在运行pytest时，这些内容不会显示出来。如果带上-s，就可以显示了。</p><p>运行模式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pytest test_se.py -s</span><br></pre></td></tr></table></figure><p>  另外，pytest的多种运行模式是可以叠加执行的，比如说，你想同时运行4个进程，又想打印出print的内容。可以用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pytest test_se.py -s -n 4</span><br></pre></td></tr></table></figure><p> 以用‘-s’参数或者 ‘–capture=no’，这样就可以输出所有测试用的print信息 ，但是并不是实时显示而是等程序运行结束时一起显示。</p><h3 id="5-6-使用log模块"><a href="#5-6-使用log模块" class="headerlink" title="5.6 使用log模块"></a>5.6 使用log模块</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"></span><br><span class="line">logging.basicConfig(level=logging.DEBUG)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_1</span><span class="params">()</span>:</span></span><br><span class="line">    log = logging.getLogger(<span class="string">'test_1'</span>)</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    log.debug(<span class="string">'after 1 sec'</span>)</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    log.debug(<span class="string">'after 2 sec'</span>)</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    log.debug(<span class="string">'after 3 sec'</span>)</span><br><span class="line">    <span class="keyword">assert</span> <span class="number">1</span>, <span class="string">'should pass'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_2</span><span class="params">()</span>:</span></span><br><span class="line">    log = logging.getLogger(<span class="string">'test_2'</span>)</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    log.debug(<span class="string">'after 1 sec'</span>)</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    log.debug(<span class="string">'after 2 sec'</span>)</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    log.debug(<span class="string">'after 3 sec'</span>)</span><br><span class="line">    <span class="keyword">assert</span> <span class="number">0</span>, <span class="string">'failing for demo purposes'</span></span><br></pre></td></tr></table></figure><p>pytest用logging和–capture=no实现实时输出log信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pytest -s slowTest_logging.py</span><br></pre></td></tr></table></figure><!--Test no  display   --><h2 id="6，扩展阅读"><a href="#6，扩展阅读" class="headerlink" title="6，扩展阅读"></a>6，扩展阅读</h2><ol start="2"><li><p><a href="https://www.jianshu.com/p/932a4d9f78f8" target="_blank" rel="noopener">全功能Python测试框架：pytest</a></p></li><li><p><a href="https://docs.pytest.org/en/latest/contents.html" target="_blank" rel="noopener">Full pytest documentation</a></p></li><li><p><a href="https://www.cnblogs.com/sparkling-ly/category/851617.html" target="_blank" rel="noopener">Pytest学习笔记</a></p></li><li><p><a href="https://blog.csdn.net/liuchunming033/article/category/3193659" target="_blank" rel="noopener">pytest单元测试框架</a> </p></li></ol><p>–&gt;</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt; 安徐正静&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;1、pytest-特点&quot;&gt;&lt;a href=&quot;#1、pytest-特点&quot; class=&quot;headerlink&quot; title=&quot;1、pytest 特点&quot;&gt;&lt;/a&gt;1、pytest 特点&lt;/
      
    
    </summary>
    
    
      <category term="python入门到进阶" scheme="https://frank2019.github.io/categories/python%E5%85%A5%E9%97%A8%E5%88%B0%E8%BF%9B%E9%98%B6/"/>
    
    
      <category term="python" scheme="https://frank2019.github.io/tags/python/"/>
    
      <category term="pytest" scheme="https://frank2019.github.io/tags/pytest/"/>
    
  </entry>
  
  <entry>
    <title>AndroidCamera 4 CaptureRequest和CaptureResult</title>
    <link href="https://frank2019.github.io/2020/03/08/Android_4_CaptureRequest%E5%92%8CCaptureResult/"/>
    <id>https://frank2019.github.io/2020/03/08/Android_4_CaptureRequest%E5%92%8CCaptureResult/</id>
    <published>2020-03-08T13:45:55.062Z</published>
    <updated>2020-03-08T13:56:30.799Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CaptureRequest"><a href="#CaptureRequest" class="headerlink" title="CaptureRequest"></a>CaptureRequest</h1><p>捕获请求，可以为不同的场景(预览 拍照)创建不同的请求，配置不同的属性，如：预览分辨率、预览目标、对焦模式、曝光模式等。</p><ul><li><p>包含捕获硬件（sensor、镜头、闪光灯等）、管道、控制算法、输出buffer，发送图像到的目标的配置。</p></li><li><p>通过 CameraDevice 对象的 createCaptureRequest() 方法得到一个 CaptureRequest.Builder 对象，基本配置都是通过该构造者来配置；最后通过 CaptureRequest.Builder 对象的 build() 方法便可得到CaptureRequest 实例。</p></li><li><p>CaptureRequest 通过CameraCaptureSession的capture 或setRepeatingRequest方法，发送给camera device 捕获图像。</p></li><li><p>CaptureRequest  继承了<code>Parcelable</code> 接口，支持序列化。</p></li></ul><h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h2><h3 id="CaptureRequest-Builder"><a href="#CaptureRequest-Builder" class="headerlink" title="CaptureRequest.Builder"></a>CaptureRequest.Builder</h3><p>典型的建造者模式，是 CaptureRequest 的构建者。</p><p>使用<code>CameraDevice.createCaptureRequest(int)</code>方法获取一个 <code>CaptureRequest.Builder</code>对象。其中的 int 取值为：(定义在CameraDevice中)</p><ul><li>TEMPLATE_PREVIEW ： 用于创建一个相机预览请求。相机会优先保证高帧率而不是高画质。适用于所有相机设备。</li><li>TEMPLATE_STILL_CAPTURE ： 用于创建一个拍照请求。相机会优先保证高画质而不是高帧率。适用于所有相机设备。</li><li>TEMPLATE_RECORD ： 用于创建一个录像请求。相机会使用标准帧率，并设置录像级别的画质。适用于所有相机设备。</li><li>TEMPLATE_VIDEO_SNAPSHOT ： 用于创建一个录像时拍照的请求。相机会尽可能的保证照片质量的同时不破坏正在录制的视频质量。适用于硬件支持级别高于 LEGACY 的相机设备。</li><li>EMPLATE_ZERO_SHUTTER_LAG ： 用于创建一个零延迟拍照的请求。相机会尽可能的保证照片质量的同时不损失预览图像的帧率，3A（自动曝光、自动聚焦、自动白平衡）都为 auto 模式。只适用于支持PRIVATE_REPROCESSING 和 YUV_REPROCESSING 的相机设备。</li><li>TEMPLATE_MANUAL ： 用于创建一个手动控制相机参数的请求。相机所有自动控制将被禁用，后期处理参数为预览质量，手动控制参数被设置为合适的默认值，需要用户自己根据需求来调整各参数。适用于支持MANUAL_SENSOR 的相机设备。</li></ul><h4 id="支持的方法"><a href="#支持的方法" class="headerlink" title="支持的方法"></a>支持的方法</h4><h5 id="1、addTarget"><a href="#1、addTarget" class="headerlink" title="1、addTarget"></a>1、addTarget</h5><p>添加一个请求的输出surface，注意这个surface必须包含在 <code>CameraDevice.createCaptureSession()</code> 方法设置的输出surface集合中</p><h5 id="2、removeTarget"><a href="#2、removeTarget" class="headerlink" title="2、removeTarget"></a>2、removeTarget</h5><p>移除指定的输出surface</p><h5 id="3、CaptureRequest-build"><a href="#3、CaptureRequest-build" class="headerlink" title="3、CaptureRequest build()"></a>3、CaptureRequest build()</h5><p>使用当前配置构建一个CaptureRequest对象</p><h5 id="4、T-get-Key-key"><a href="#4、T-get-Key-key" class="headerlink" title="4、T get(Key key)"></a>4、T get(Key key)</h5><p> CaptureRequest.Builder 的属性字段查询。这些字段定义了相机的具体配置。</p><h5 id="5、set-Key-key-T-value"><a href="#5、set-Key-key-T-value" class="headerlink" title="5、set(Key key, T value)"></a>5、set(Key key, T value)</h5><p>设置指定key的值</p><h5 id="6、void-setTag-Object-tag"><a href="#6、void-setTag-Object-tag" class="headerlink" title="6、void setTag(Object tag)"></a>6、void setTag(Object tag)</h5><p>为该请求设置一个标签</p><h2 id="支持的方法-1"><a href="#支持的方法-1" class="headerlink" title="支持的方法"></a>支持的方法</h2><h3 id="1、T-get-Key-key"><a href="#1、T-get-Key-key" class="headerlink" title="1、T get(Key key)"></a>1、T get(Key key)</h3><p>和 CaptureRequest.Builder 中的 get 方法效果是一样的。</p><h3 id="2、List-lt-Key-lt-gt-gt-getKeys"><a href="#2、List-lt-Key-lt-gt-gt-getKeys" class="headerlink" title="2、List&lt;Key&lt;?&gt;&gt; getKeys()"></a>2、List&lt;Key&lt;?&gt;&gt; getKeys()</h3><p>返回映射中包含的所有 Key 的列表。</p><h3 id="3、Object-getTag"><a href="#3、Object-getTag" class="headerlink" title="3、Object getTag()"></a>3、Object getTag()</h3><p>检索此请求的标签，如果有的话。对应 CaptureRequest.Builder 中的 setTag() 方法。</p><h3 id="4、boolean-isReprocess"><a href="#4、boolean-isReprocess" class="headerlink" title="4、boolean isReprocess()"></a>4、boolean isReprocess()</h3><p>判断这是否是一个再处理的请求。</p><h3 id><a href="#" class="headerlink" title></a></h3><h2 id="实例代码"><a href="#实例代码" class="headerlink" title="实例代码"></a>实例代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">captureStillPicture</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> Activity activity = getActivity();</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == activity || <span class="keyword">null</span> == mCameraDevice) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 1. 先拿到一个 CaptureRequest.Builder 对象</span></span><br><span class="line">        <span class="keyword">final</span> CaptureRequest.Builder captureBuilder =</span><br><span class="line">                mCameraDevice.createCaptureRequest(CameraDevice.TEMPLATE_STILL_CAPTURE);</span><br><span class="line">        captureBuilder.addTarget(mImageReader.getSurface());</span><br><span class="line">        <span class="comment">// 2. 通过 CaptureRequest.Builder 对象设置一些捕捉请求的配置</span></span><br><span class="line">        captureBuilder.set(CaptureRequest.CONTROL_AF_MODE,</span><br><span class="line">                CaptureRequest.CONTROL_AF_MODE_CONTINUOUS_PICTURE);</span><br><span class="line">        setAutoFlash(captureBuilder);</span><br><span class="line">        <span class="keyword">int</span> rotation = activity.getWindowManager().getDefaultDisplay().getRotation();</span><br><span class="line">        captureBuilder.set(CaptureRequest.JPEG_ORIENTATION, getOrientation(rotation));</span><br><span class="line">        CameraCaptureSession.CaptureCallback CaptureCallback</span><br><span class="line">                = <span class="keyword">new</span> CameraCaptureSession.CaptureCallback() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCaptureCompleted</span><span class="params">(@NonNull CameraCaptureSession session,</span></span></span><br><span class="line"><span class="function"><span class="params">                                           @NonNull CaptureRequest request,</span></span></span><br><span class="line"><span class="function"><span class="params">                                           @NonNull TotalCaptureResult result)</span> </span>&#123;</span><br><span class="line">                <span class="comment">// start preview</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        mCaptureSession.stopRepeating();</span><br><span class="line">        mCaptureSession.abortCaptures();</span><br><span class="line">        <span class="comment">// 3. 通过 CaptureRequest.Builder 对象的 `build()` 方法构建一个 CaptureRequest 对象</span></span><br><span class="line">        mCaptureSession.capture(captureBuilder.build(), CaptureCallback, <span class="keyword">null</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (CameraAccessException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="CaptureResult"><a href="#CaptureResult" class="headerlink" title="CaptureResult"></a>CaptureResult</h1><p>CaptureResult 表示捕捉的结果，是从图像传感器捕获单个图像的结果的子集。包含捕获硬件(传感器、镜头、闪光灯)、处理管道、控制算法和输出缓冲区的最终配置的子集。</p><p>捕获结果由camera在对CaptureRequest进行处理后产生。还可以对捕获结果查询为捕获请求列出的所有属性，以确定捕获使用的最终值。结果还包括捕获过程中相机设备状态的附加元数据。<br>CaptureResult 对象也是不可变的。常使用的子类是 <code>TotalCaptureResult</code>。</p><h2 id="内部类-1"><a href="#内部类-1" class="headerlink" title="内部类"></a>内部类</h2><p>只有一个 <code>CaptureResult.Key&lt;T&gt;</code> 的内部类，用于 CaptureResult 类的字段查找。</p><p>类比于 <code>CameraCharacteristics.Key</code> 和 <code>CaptureRequest.Key</code>。</p><h2 id="支持的方法-2"><a href="#支持的方法-2" class="headerlink" title="支持的方法"></a>支持的方法</h2><h3 id="1、T-get-Key-key-1"><a href="#1、T-get-Key-key-1" class="headerlink" title="1、T get(Key key)"></a>1、T get(Key key)</h3><p>获取 CaptureResult 中指定 key 的值，key 为 CaptureResult 类中的那些静态常量。</p><h3 id="2、long-getFrameNumber"><a href="#2、long-getFrameNumber" class="headerlink" title="2、long getFrameNumber()"></a>2、long getFrameNumber()</h3><p>获取该结果申请的帧的id。</p><h3 id="3、List-lt-Key-lt-gt-gt-getKeys"><a href="#3、List-lt-Key-lt-gt-gt-getKeys" class="headerlink" title="3、List&lt;Key&lt;?&gt;&gt; getKeys()"></a>3、List&lt;Key&lt;?&gt;&gt; getKeys()</h3><p>返回映射中包含的所有 Key 的列表。</p><h3 id="4、CaptureRequest-getRequest"><a href="#4、CaptureRequest-getRequest" class="headerlink" title="4、CaptureRequest getRequest()"></a>4、CaptureRequest getRequest()</h3><p>返回这个结果对应的 CaptureRequest 对象。</p><p>5、int getSequenceId()</p><p>获取发生故障时的序列ID。</p><h2 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h2><p>源码中system/media/camera/docs  存放了上文 提到的camera device key值及对应属性的解释相关文档。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;CaptureRequest&quot;&gt;&lt;a href=&quot;#CaptureRequest&quot; class=&quot;headerlink&quot; title=&quot;CaptureRequest&quot;&gt;&lt;/a&gt;CaptureRequest&lt;/h1&gt;&lt;p&gt;捕获请求，可以为不同的场景(预览 拍照)创建
      
    
    </summary>
    
    
      <category term="AndroidCamera" scheme="https://frank2019.github.io/categories/AndroidCamera/"/>
    
    
      <category term="Android" scheme="https://frank2019.github.io/tags/Android/"/>
    
      <category term="Camera2API" scheme="https://frank2019.github.io/tags/Camera2API/"/>
    
      <category term="CaptureRequest" scheme="https://frank2019.github.io/tags/CaptureRequest/"/>
    
      <category term="CaptureResult - Preview" scheme="https://frank2019.github.io/tags/CaptureResult-Preview/"/>
    
  </entry>
  
  <entry>
    <title>AndroidCamera 3 CameraManager</title>
    <link href="https://frank2019.github.io/2020/03/08/Android_3_ClassCameraManager/"/>
    <id>https://frank2019.github.io/2020/03/08/Android_3_ClassCameraManager/</id>
    <published>2020-03-08T13:45:55.059Z</published>
    <updated>2020-03-08T13:56:04.531Z</updated>
    
    <content type="html"><![CDATA[<h2 id="CameraManager"><a href="#CameraManager" class="headerlink" title="CameraManager"></a>CameraManager</h2><h2 id="1、概述"><a href="#1、概述" class="headerlink" title="1、概述"></a>1、概述</h2><p>CameraManager 是一个负责查询和建立相机连接的系统服务，关键功能：</p><ol><li>将相机信息封装到 CameraCharacteristics 中，并提获取 CameraCharacteristics 实例的方式。</li><li>根据指定的相机 ID 连接相机设备。</li><li>提供将闪光灯设置成手电筒模式的快捷方式。</li></ol><h2 id="2、获取实例"><a href="#2、获取实例" class="headerlink" title="2、获取实例"></a>2、获取实例</h2><p>通过 <code>Context</code> 类的 <code>getSystemService()</code> 方法来获取一个系统服务</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CameraManager manager = (CameraManager) context.getSystemService(Context.CAMERA_SERVICE);</span><br></pre></td></tr></table></figure><h2 id="3、内部类"><a href="#3、内部类" class="headerlink" title="3、内部类"></a>3、内部类</h2><h3 id="CameraManager-AvailabilityCallback"><a href="#CameraManager-AvailabilityCallback" class="headerlink" title="CameraManager.AvailabilityCallback"></a>CameraManager.AvailabilityCallback</h3><p>相机设备的可用状态发生变化时，触发回调。</p><ul><li>public void onCameraAvailable(@NonNull String cameraId)</li><li>public void onCameraUnavailable(@NonNull String cameraId) </li></ul><p>String cameraId  相机设备的唯一标识。</p><h3 id="CameraManager-TorchCallback"><a href="#CameraManager-TorchCallback" class="headerlink" title="CameraManager.TorchCallback"></a>CameraManager.TorchCallback</h3><p>闪光灯的可用状态发生变化时触发回调。</p><ul><li>public void onTorchModeUnavailable(@NonNull String cameraId)</li><li>public void onTorchModeChanged(@NonNull String cameraId, boolean enabled)<ul><li>String cameraId  相机设备的唯一标识。</li><li>boolean enabled 闪光灯变化前的状态</li></ul></li></ul><h3 id="CameraManager-CameraManagerGlobal"><a href="#CameraManager-CameraManagerGlobal" class="headerlink" title="CameraManager.CameraManagerGlobal"></a>CameraManager.CameraManagerGlobal</h3><p>全局Camera管理实例，单例，保持一个与camera service得连接，同时分发API注册得可用回调。</p><h2 id="4、主要接口"><a href="#4、主要接口" class="headerlink" title="4、主要接口"></a>4、主要接口</h2><h3 id="获取Camera设备列表"><a href="#获取Camera设备列表" class="headerlink" title="获取Camera设备列表"></a>获取Camera设备列表</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@NonNull</span></span><br><span class="line"><span class="keyword">public</span> String[] getCameraIdList() <span class="keyword">throws</span> CameraAccessException &#123;</span><br><span class="line"><span class="keyword">return</span> CameraManagerGlobal.get().getCameraIdList();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="注册可用状态变化回调"><a href="#注册可用状态变化回调" class="headerlink" title="注册可用状态变化回调"></a>注册可用状态变化回调</h3><p>注册一个回调用来当可用状态变化的时候，进行通知。</p><ul><li>注册一个相同的回调，那么新的会替代旧的。</li><li>第一次注册回调时，立刻激活一次回调，回报当前可用的camera设备；</li><li>不管什么时候调用了camera被打开了都会触发回调；</li><li>如果没有必要时，记得注销回调。不然会占用资源。 回调将独立于一般Activity的生命周期，独立调用CameraManger。</li><li>支持再给定的Handle或Executor 上触发回调；</li></ul><p><strong>支持的接口</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerAvailabilityCallback</span><span class="params">(@NonNull AvailabilityCallback callback,</span></span></span><br><span class="line"><span class="function"><span class="params">            @Nullable Handler handler)</span> </span>&#123;</span><br><span class="line">        CameraManagerGlobal.get().registerAvailabilityCallback(callback,</span><br><span class="line">                CameraDeviceImpl.checkAndWrapHandler(handler));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li><p>@NonNull AvailabilityCallback callback     新的回调</p></li><li><p>@Nullable Handler handler   在之上会调用callback，如果设置为null，则使用当前线程(android.os.Looper looper);</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerAvailabilityCallback</span><span class="params">(@NonNull @CallbackExecutor Executor executor,</span></span></span><br><span class="line"><span class="function"><span class="params">           @NonNull AvailabilityCallback callback)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (executor == <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"executor was null"</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       CameraManagerGlobal.get().registerAvailabilityCallback(callback, executor);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><ul><li>@NonNull @CallbackExecutor Executor executor,    在之上调用callback。</li><li>@NonNull AvailabilityCallback callback   新的回调。</li></ul><h3 id="注销可用状态回调"><a href="#注销可用状态回调" class="headerlink" title="注销可用状态回调"></a>注销可用状态回调</h3><p>移除之前注册的回调，此callback 不会再接收连接和断开的事件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unregisterAvailabilityCallback</span><span class="params">(@NonNull AvailabilityCallback callback)</span> </span>&#123;</span><br><span class="line">        CameraManagerGlobal.get().unregisterAvailabilityCallback(callback);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="注册闪光灯回调"><a href="#注册闪光灯回调" class="headerlink" title="注册闪光灯回调"></a>注册闪光灯回调</h3><p>注册回调用于关注闪光灯状态</p><ul><li><p>注册一个相同的回调，那么新的会替代旧的。</p></li><li><p>第一次注册时，会立刻回调具备闪光灯单元的所有Camera设备。</p></li><li><p>注册此回调到camera service后，记得不需要的时候注销此回调，不然一旦闪光灯状态变化会触发回调，影响相应资源释放。回调将独立于一般Activity的生命周期，独立调用CameraManger。</p></li><li><p>支持再给定的Handle或Executor 上触发回调。</p></li></ul><p><strong>支持的接口</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerTorchCallback</span><span class="params">(@NonNull TorchCallback callback, @Nullable Handler handler)</span> </span>&#123;</span><br><span class="line">        CameraManagerGlobal.get().registerTorchCallback(callback,</span><br><span class="line">                CameraDeviceImpl.checkAndWrapHandler(handler));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li><p>@NonNull TorchCallback callback     新的回调</p></li><li><p>@Nullable Handler handler   在之上会调用callback，如果设置为null，则使用当前线程(android.os.Looper looper);</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerTorchCallback</span><span class="params">(@NonNull @CallbackExecutor Executor executor,</span></span></span><br><span class="line"><span class="function"><span class="params">           @NonNull TorchCallback callback)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (executor == <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"executor was null"</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       CameraManagerGlobal.get().registerTorchCallback(callback, executor);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><ul><li>@NonNull @CallbackExecutor Executor executor,    在之上调用callback。</li><li>@NonNull TorchCallback  callback   新的回调。</li></ul><h3 id="注销闪光灯回调"><a href="#注销闪光灯回调" class="headerlink" title="注销闪光灯回调"></a>注销闪光灯回调</h3><p>移除之前注册的回调，此callback 不会再接收闪光灯状态变化的事件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unregisterTorchCallback</span><span class="params">(@NonNull TorchCallback callback)</span> </span>&#123;</span><br><span class="line">        CameraManagerGlobal.get().unregisterTorchCallback(callback);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="获取Camera特性"><a href="#获取Camera特性" class="headerlink" title="获取Camera特性"></a>获取Camera特性</h3><p>查询并获取指定Camera的特性和能力，这些特性是不可修改的。</p><ul><li>从API 29 开始，此接口也可用于查询物理摄像头的特性，物理摄像头仅可以是逻辑复合摄像头的一部分，不能直接被openCamera接口打开。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@NonNull</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> CameraCharacteristics <span class="title">getCameraCharacteristics</span><span class="params">(@NonNull String cameraId)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> CameraAccessException</span></span><br></pre></td></tr></table></figure><ul><li>@NonNull String cameraId   可以是一个独立的camera 或者仅是一个物理摄像头。</li></ul><h3 id="打开Camera"><a href="#打开Camera" class="headerlink" title="打开Camera"></a>打开Camera</h3><p>建立一个到给定Camera的连接。</p><ul><li>及时打开的是使用 getCameraIdList 获取的cameraId指定的Camera 也可能操作失败，因为Camera有可能已经断开连接或者被其他更高级别的API打开而被占用。</li><li>即使低优先级的client已经打开了Camera，高优先级的client也可以成功打开Camera，此时低级别的Client会收到回调事件android.hardware.camera2.CameraDevice.StateCallback#onDisconnected。如果你的client处于 顶层或者前台的Activity 那么你的client可以获得更高的优先级。</li><li>一旦成功打开Camera，会触发回调 CameraDevice.StateCallback#onOpened，那么你就可以使用Camera的相关操作，比如发起拍照请求等。</li><li>如果在初始化期间Camera断开，那么会有一个CameraDevice.StateCallback#onDisconnected回调其中带有Camera状态，回调CameraDevice.StateCallback#onOpened就会被跳过。</li><li>如果打开Camera失败，会触发回调CameraDevice.StateCallback#onError onError，随后在这个Camera上的调用就会抛出异常CameraAccessException。</li></ul><p><strong>支持的接口</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequiresPermission</span>(android.Manifest.permission.CAMERA)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">openCamera</span><span class="params">(@NonNull String cameraId,</span></span></span><br><span class="line"><span class="function"><span class="params">           @NonNull <span class="keyword">final</span> CameraDevice.StateCallback callback, </span></span></span><br><span class="line"><span class="function"><span class="params">           @Nullable Handler handler)</span></span></span><br><span class="line"><span class="function">           <span class="keyword">throws</span> CameraAccessException</span></span><br></pre></td></tr></table></figure><ul><li>@NonNull String cameraId：  camera 唯一标识</li><li>CameraDevice.StateCallback callback     CameraDevice状态回调</li><li>@Nullable Handler handler     在其上运行回调。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequiresPermission</span>(android.Manifest.permission.CAMERA)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">openCamera</span><span class="params">(@NonNull String cameraId,</span></span></span><br><span class="line"><span class="function"><span class="params">            @NonNull @CallbackExecutor Executor executor,</span></span></span><br><span class="line"><span class="function"><span class="params">            @NonNull <span class="keyword">final</span> CameraDevice.StateCallback callback)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> CameraAccessException</span></span><br></pre></td></tr></table></figure><ul><li>@NonNull String cameraId：  camera 唯一标识</li><li>@NonNull @CallbackExecutor Executor executor    CameraDevice状态回调</li><li>@Nullable Handler handler     在其上运行回调。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">openCameraForUid</span><span class="params">(@NonNull String cameraId,</span></span></span><br><span class="line"><span class="function"><span class="params">           @NonNull <span class="keyword">final</span> CameraDevice.StateCallback callback, </span></span></span><br><span class="line"><span class="function"><span class="params">           @NonNull Executor executor,</span></span></span><br><span class="line"><span class="function"><span class="params">           <span class="keyword">int</span> clientUid)</span></span></span><br><span class="line"><span class="function">           <span class="keyword">throws</span> CameraAccessException</span></span><br></pre></td></tr></table></figure><ul><li><p>此接口为隐藏接口</p></li><li><p>int clientUid      UID为clientUid      的应用将打开Camera，一般设置为USE_CALLING_UID，除非是可信任的服务。</p></li></ul><h3 id="设置闪光灯模式"><a href="#设置闪光灯模式" class="headerlink" title="设置闪光灯模式"></a>设置闪光灯模式</h3><p>设置指定camera得闪光灯模式，不需要打开camera。</p><ul><li><p>使用getCameraIdList获取可用Camera列表，使用getCameraCharacteristics查看Camera是否包含闪光灯。即使Camera包含闪光灯，也有可能打开闪光灯失败，因为或许在使用中。</p></li><li><p>setTorchMode调用成功，CameraManager.TorchCallback#onTorchModeChanged会触发。即使打开了闪光灯，应用也不是独占闪光灯或者Camera。如果最后一个打开闪光灯得应用退出了，闪光灯将关闭。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTorchMode</span><span class="params">(@NonNull String cameraId, <span class="keyword">boolean</span> enabled)</span></span></span><br><span class="line"><span class="function">           <span class="keyword">throws</span> CameraAccessException </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (CameraManagerGlobal.sCameraServiceDisabled) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"No cameras available on device"</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       CameraManagerGlobal.get().setTorchMode(cameraId, enabled);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="5、核心实现"><a href="#5、核心实现" class="headerlink" title="5、核心实现"></a>5、核心实现</h2><p>相关代码位于源码位置：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">frameworks\base\core\java\android\hardware\camera2\CameraManager.java</span><br><span class="line">./frameworks/av/camera/aidl/android/hardware/ICameraServiceListener.aidl</span><br><span class="line">./frameworks/av/camera/aidl/android/hardware/ICameraServiceProxy.aidl</span><br><span class="line">./frameworks/av/camera/aidl/android/hardware/ICameraService.aidl</span><br><span class="line">。。。</span><br></pre></td></tr></table></figure><ul><li><p><strong>Application framework：</strong>用于给APP提供访问hardware的Camera API2，通过binder来访问camera service。</p></li><li><p><strong>AIDL:</strong> 基于Binder实现的一个用于让App framework代码访问natice 代码的接口。其实现存在于下述路径：frameworks/av/camera/aidl/android/hardware。其中：</p><ul><li>ICameraService 是相机服务的接口。用于请求连接、添加监听等。</li><li>ICameraDeviceUser 是已打开的特定相机设备的接口。应用框架可通过它访问具体设备。</li><li>ICameraServiceListener 和 ICameraDeviceCallbacks 分别是从 CameraService 和 CameraDevice 到应用框架的回调。</li></ul></li><li><p><strong>Natice framework</strong>：frameworks/av/。提供了ICameraService、ICameraDeviceUser、ICameraDeviceCallbacks、ICameraServiceListener等aidl接口的实现。以及camera  server的main函数。</p></li><li><p><strong>Binder IPC interface</strong>：提供进程间通信的接口，APP和CameraService的通信、CameraService和HAL的通信。其中，AIDL、HIDL都是基于Binder实现的。</p></li><li><p><strong>Camera Service</strong>：frameworks/av/services/camera/。同APP、HAL交互的服务，起到了承上启下的作用。</p></li><li><p><strong>HAL：</strong>Google的HAL定义了可以让Camera Service访问的标准接口。对于供应商而言，必须要实现这些接口。</p></li></ul><p>查看CameraManager类，其主要功能由其内部类 CameraManagerGlobal 代理实现。CameraManagerGlobal  是一个单例，CameraManagerGlobal 是真正的实现层，它与 CameraService 创建连接，从而创建相机的连路。</p><p><img src="/2020/03/08/Android_3_ClassCameraManager/CameraManagerGlobal.png" alt></p><p><img src="/2020/03/08/Android_3_ClassCameraManager/CameraDigram.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;CameraManager&quot;&gt;&lt;a href=&quot;#CameraManager&quot; class=&quot;headerlink&quot; title=&quot;CameraManager&quot;&gt;&lt;/a&gt;CameraManager&lt;/h2&gt;&lt;h2 id=&quot;1、概述&quot;&gt;&lt;a href=&quot;#1、概述&quot;
      
    
    </summary>
    
    
      <category term="AndroidCamera" scheme="https://frank2019.github.io/categories/AndroidCamera/"/>
    
    
      <category term="Android" scheme="https://frank2019.github.io/tags/Android/"/>
    
      <category term="Camera2API" scheme="https://frank2019.github.io/tags/Camera2API/"/>
    
      <category term="CameraManager - Preview" scheme="https://frank2019.github.io/tags/CameraManager-Preview/"/>
    
  </entry>
  
  <entry>
    <title>AndroidCamera 2 Camera2API概述</title>
    <link href="https://frank2019.github.io/2020/03/08/Android_2_Camera2API%E6%A6%82%E8%BF%B0/"/>
    <id>https://frank2019.github.io/2020/03/08/Android_2_Camera2API%E6%A6%82%E8%BF%B0/</id>
    <published>2020-03-08T13:45:55.057Z</published>
    <updated>2020-03-08T13:53:16.873Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0、引言"><a href="#0、引言" class="headerlink" title="0、引言"></a>0、引言</h2><ul><li><p>从 Android 5.0 开始，Google 引入了一套全新的相机框架 Camera2（android.hardware.camera2）</p></li><li><p>并废弃了旧的相机框架 Camera1（android.hardware.Camera）</p></li></ul><h2 id="1、Pipeline"><a href="#1、Pipeline" class="headerlink" title="1、Pipeline"></a>1、Pipeline</h2><p>Camera2 的 API 模型被设计成一个 Pipeline（管道），它按顺序处理每一帧的请求并返回请求结果给客户端。下面这张来自官方的图展示了 Pipeline 的工作流程，</p><p><img src="/2020/03/08/Android_2_Camera2API%E6%A6%82%E8%BF%B0/1.png" alt></p><p>为了解释上面的示意图，假设我们想要同时拍摄两张不同尺寸的图片，并且在拍摄的过程中闪光灯必须亮起来。整个拍摄流程如下：</p><ol><li>创建一个用于从 Pipeline 获取图片的 CaptureRequest。</li><li>修改 CaptureRequest 的闪光灯配置，让闪光灯在拍照过程中亮起来。</li><li>创建两个不同尺寸的 Surface 用于接收图片数据，并且将它们添加到 CaptureRequest 中。</li><li>发送配置好的 CaptureRequest 到 Pipeline 中等待它返回拍照结果。</li></ol><p>一个新的 CaptureRequest 会被放入一个被称作 Pending Request Queue 的队列中等待被执行，当 In-Flight Capture Queue 队列空闲的时候就会从 Pending Request Queue 获取若干个待处理的 CaptureRequest，并且根据每一个 CaptureRequest 的配置进行 Capture 操作。最后我们从不同尺寸的 Surface 中获取图片数据并且还会得到一个包含了很多与本次拍照相关的信息的 CaptureResult，流程结束。</p><h2 id="2、Supported-Hardware-Level"><a href="#2、Supported-Hardware-Level" class="headerlink" title="2、Supported Hardware Level"></a>2、Supported Hardware Level</h2><p>相机功能的强大与否和硬件息息相关，不同厂商对 Camera2 的支持程度也不同，所以 Camera2 定义了一个叫做 Supported Hardware Level 的重要概念，其作用是将不同设备上的 Camera2 根据功能的支持情况划分成多个不同级别以便开发者能够大概了解当前设备上 Camera2 的支持情况。截止到 Android P 为止，从低到高一共有 LEGACY、LIMITED、FULL 和 LEVEL_3 四个级别：</p><ol><li><strong>LEGACY</strong>：向后兼容的级别，处于该级别的设备意味着它只支持 Camera1 的功能，不具备任何 Camera2 高级特性。</li><li><strong>LIMITED</strong>：除了支持 Camera1 的基础功能之外，还支持部分 Camera2 高级特性的级别。</li><li><strong>FULL</strong>：支持所有 Camera2 的高级特性。</li><li><strong>LEVEL_3</strong>：新增更多 Camera2 高级特性，例如 YUV 数据的后处理等。</li></ol><h2 id="3、Capture"><a href="#3、Capture" class="headerlink" title="3、Capture"></a>3、Capture</h2><p>相机的所有操作和参数配置最终都是服务于图像捕获，例如对焦是为了让某一个区域的图像更加清晰，调节曝光补偿是为了调节图像的亮度。因此，在 Camera2 里面所有的相机操作和参数配置都被抽象成 Capture（捕获），所以不要简单的把 Capture 直接理解成是拍照，因为 Capture 操作可能仅仅是为了让预览画面更清晰而进行对焦而已。如果你熟悉 Camera1，那你可能会问 <code>setFlashMode()</code> 在哪？<code>setFocusMode()</code> 在哪？<code>takePicture()</code> 在哪？告诉你，它们都是通过 Capture 来实现的。</p><p>Capture 从执行方式上又被细分为【单次模式】、【多次模式】和【重复模式】三种，我们来一一解释下：</p><ul><li><strong>单次模式（One-shot）</strong>：指的是只执行一次的 Capture 操作，例如设置闪光灯模式、对焦模式和拍一张照片等。多个一次性模式的 Capture 会进入队列按顺序执行。</li><li><strong>多次模式（Burst）</strong>：指的是连续多次执行指定的 Capture 操作，该模式和多次执行单次模式的最大区别是连续多次 Capture 期间不允许插入其他任何 Capture 操作，例如连续拍摄 100 张照片，在拍摄这 100 张照片期间任何新的 Capture 请求都会排队等待，直到拍完 100 张照片。多组多次模式的 Capture 会进入队列按顺序执行。</li><li><strong>重复模式（Repeating）</strong>：指的是不断重复执行指定的 Capture 操作，当有其他模式的 Capture 提交时会暂停该模式，转而执行其他被模式的 Capture，当其他模式的 Capture 执行完毕后又会自动恢复继续执行该模式的 Capture，例如显示预览画面就是不断 Capture 获取每一帧画面。该模式的 Capture 是全局唯一的，也就是新提交的重复模式 Capture 会覆盖旧的重复模式 Capture。</li></ul><h2 id="4、CameraManager"><a href="#4、CameraManager" class="headerlink" title="4、CameraManager"></a>4、CameraManager</h2><p>CameraManager 是一个负责查询和建立相机连接的系统服务，它的功能不多，这里列出几个 CameraManager 的关键功能：</p><ol><li>将相机信息封装到 CameraCharacteristics 中，并提获取 CameraCharacteristics 实例的方式。</li><li>根据指定的相机 ID 连接相机设备。</li><li>提供将闪光灯设置成手电筒模式的快捷方式。</li></ol><h2 id="5、CameraCharacteristics"><a href="#5、CameraCharacteristics" class="headerlink" title="5、CameraCharacteristics"></a>5、CameraCharacteristics</h2><p>CameraCharacteristics 是一个只读的相机信息提供者，其内部携带大量的相机信息，包括</p><ul><li>代表相机朝向的 <code>LENS_FACING</code>；</li><li>判断闪光灯是否可用的 <code>FLASH_INFO_AVAILABLE</code>；</li><li>获取所有可用 AE 模式的 <code>CONTROL_AE_AVAILABLE_MODES</code> 等等。</li></ul><p>如果你对 Camera1 比较熟悉，那么 CameraCharacteristics 有点像 Camera1 的 <code>Camera.CameraInfo</code> 或者 <code>Camera.Parameters</code>。</p><h2 id="6、CameraDevice"><a href="#6、CameraDevice" class="headerlink" title="6、CameraDevice"></a>6、CameraDevice</h2><p>CameraDevice 代表当前连接的相机设备，它的职责有以下四个：</p><ol><li>根据指定的参数创建 CameraCaptureSession。</li><li>根据指定的模板创建 CaptureRequest。</li><li>关闭相机设备。</li><li>监听相机设备的状态，例如断开连接、开启成功和开启失败等。</li></ol><p>熟悉 Camera1 的人可能会说 CameraDevice 就是 Camera1 的 Camera 类，实则不是，Camera 类几乎负责了所有相机的操作，而 CameraDevice 的功能则十分的单一，就是只负责建立相机连接的事务，而更加细化的相机操作则交给了稍后会介绍的 CameraCaptureSession。</p><h2 id="7、Surface"><a href="#7、Surface" class="headerlink" title="7、Surface"></a>7、Surface</h2><p>Surface 是一块用于填充图像数据的内存空间，例如你可以使用 SurfaceView 的 Surface 接收每一帧预览数据用于显示预览画面，也可以使用 ImageReader 的 Surface 接收 JPEG 或 YUV 数据。每一个 Surface 都可以有自己的尺寸和数据格式，你可以从 CameraCharacteristics 获取某一个数据格式支持的尺寸列表。</p><h2 id="8、CameraCaptureSession"><a href="#8、CameraCaptureSession" class="headerlink" title="8、CameraCaptureSession"></a>8、CameraCaptureSession</h2><p>CameraCaptureSession 实际上就是配置了目标 Surface 的 Pipeline 实例，我们在使用相机功能之前必须先创建 CameraCaptureSession 实例。一个 CameraDevice 一次只能开启一个 CameraCaptureSession，绝大部分的相机操作都是通过向 CameraCaptureSession 提交一个 Capture 请求实现的，例如拍照、连拍、设置闪光灯模式、触摸对焦、显示预览画面等等。</p><h2 id="9、CaptureRequest"><a href="#9、CaptureRequest" class="headerlink" title="9、CaptureRequest"></a>9、CaptureRequest</h2><p>CaptureRequest 是向 CameraCaptureSession 提交 Capture 请求时的信息载体，其内部包括了本次 Capture 的参数配置和接收图像数据的 Surface。CaptureRequest 可以配置的信息非常多，包括图像格式、图像分辨率、传感器控制、闪光灯控制、3A 控制等等，可以说绝大部分的相机参数都是通过 CaptureRequest 配置的。值得注意的是每一个 CaptureRequest 表示一帧画面的操作，这意味着你可以精确控制每一帧的 Capture 操作。</p><h2 id="10、CaptureResult"><a href="#10、CaptureResult" class="headerlink" title="10、CaptureResult"></a>10、CaptureResult</h2><p>CaptureResult 是每一次 Capture 操作的结果，里面包括了很多状态信息，包括闪光灯状态、对焦状态、时间戳等等。例如你可以在拍照完成的时候，通过 CaptureResult 获取本次拍照时的对焦状态和时间戳。需要注意的是，CaptureResult 并不包含任何图像数据，前面我们在介绍 Surface 的时候说了，图像数据都是从 Surface 获取的。</p><h2 id="11、一些只有-Camera2-才支持的高级特性"><a href="#11、一些只有-Camera2-才支持的高级特性" class="headerlink" title="11、一些只有 Camera2 才支持的高级特性"></a>11、一些只有 Camera2 才支持的高级特性</h2><p>如果要我给出强有力的理由解释为什么要使用 Camera2，那么通过 Camera2 提供的高级特性可以构建出更加高质量的相机应用程序应该是最佳理由了。</p><ol><li><strong>在开启相机之前检查相机信息</strong><br> 出于某些原因，你可能需要先检查相机信息再决定是否开启相机，例如检查闪光灯是否可用。在 Caemra1 上，你无法在开机相机之前检查详细的相机信息，因为这些信息都是通过一个已经开启的相机实例提供的。在 Camera2 上，我们有了和相机实例完全剥离的 CameraCharacteristics 实例专门提供相机信息，所以我们可以在不开启相机的前提下检查几乎所有的相机信息。</li><li><strong>在不开启预览的情况下拍照</strong><br> 在 Camera1 上，开启预览是一个很重要的环节，因为只有在开启预览之后才能进行拍照，因此即使显示预览画面与实际业务需求相违背的时候，你也不得不开启预览。而 Camera2 则不强制要求你必须先开启预览才能拍照。</li><li><strong>一次拍摄多张不同格式和尺寸的图片</strong><br> 在 Camera1 上，一次只能拍摄一张图片，更不同谈多张不同格式和尺寸的图片了。而 Camera2 则支持一次拍摄多张图片，甚至是多张格式和尺寸都不同的图片。例如你可以同时拍摄一张 1440x1080 的 JPEG 图片和一张全尺寸的 RAW 图片。</li><li><strong>控制曝光时间</strong><br> 在暗环境下拍照的时候，如果能够适当延长曝光时间，就可以让图像画面的亮度得到提高。在 Camera2 上，你可以在规定的曝光时长范围内配置拍照的曝光时间，从而实现拍摄长曝光图片，你甚至可以延长每一帧预览画面的曝光时间让整个预览画面在暗环境下也能保证一定的亮度。而在 Camera1 上你只能 YY 一下。</li><li><strong>连拍</strong><br> 连拍 30 张图片这样的功能在 Camera2 出现之前恐怕只有系统相机才能做到了（通过 OpenGL 截取预览画面的做法除外），也可能是出于这个原因，市面上的第三方相机无一例外都不支持连拍。有了 Camera2，你完全可以让你的相机应用程序支持连拍功能，甚至是连续拍 30 张使用不同曝光时间的图片。</li><li><strong>灵活的 3A 控制</strong><br> 3A（AF、AE、AWB）的控制在 Camera2 上得到了最大化的放权，应用层可以根据业务需求灵活配置 3A 流程并且实时获取 3A 状态，而 Camera1 在 3A 的控制和监控方面提供的接口则要少了很多。例如你可以在拍照前进行 AE 操作，并且监听本这次拍照是否点亮闪光灯。</li></ol><h2 id="12、一些从-Camera1-迁移到-Camera2-的建议"><a href="#12、一些从-Camera1-迁移到-Camera2-的建议" class="headerlink" title="12、一些从 Camera1 迁移到 Camera2 的建议"></a>12、一些从 Camera1 迁移到 Camera2 的建议</h2><p>如果你熟悉 Camera1，并且打算从 Camera1 迁移到 Camera2 的话，希望以下几个建议可以对你起到帮助：</p><ol><li>Camera1 严格区分了预览和拍照两个流程，而 Camera2 则把这两个流程都抽象成了 Capture 行为，只不过一个是不断重复的 Capture，一个是一次性的 Capture 而已，所以建议你不要带着过多的 Camera1 思维使用 Camera2，避免因为思维上的束缚而无法充分利用 Camera2 灵活的 API。</li><li>如同 Camera1 一样，Camera2 的一些 API 调用也会耗时，所以建议你使用独立的线程执行所有的相机操作，尽量避免直接在主线程调用 Camera2 的 API，HandlerThread 是一个不错的选择。</li><li>Camera2 所有的相机操作都可以注册相关的回调接口，然后在不同的回调方法里写业务逻辑，这可能会让你的代码因为不够线性而错综复杂，建议你可以尝试使用子线程的阻塞方式来尽可能地保证代码的线性执行（熟悉 Dart 的人一定很喜欢它的 async 和 await 操作）。例如在子线程阻塞等待 CaptureResult，然后继续执行后续的操作，而不是将代码拆分到到 <code>CaptureCallback.onCaptureCompleted()</code> 方法里。</li><li>你可以认为 Camera1 是 Camera2 的一个子集，也就是说 Camera1 能做的事情 Camera2 一定能做，反过来则不一定行得通。</li><li>如果你的应用程序需要同时兼容 Camera1 和 Camera2，个人建议分开维护，因为 Camera1 蹩脚的 API 设计很可能让 Camera2 灵活的 API 无法得到充分的发挥，另外将两个设计上完全不兼容的东西搅和在一起带来的痛苦可能远大于其带来便利性，多写一些冗余的代码也许还更开心。</li><li>官方说 Camera2 的性能会更好，这句话听听就好，起码在较早期的一些机器上运行 Camera2 的性能并没有比 Camera1 好。</li><li>当设备的 Supported Hardware Level 低于 FULL 的时候，建议还是使用 Camera1，因为 FULL 级别以下的 Camera2 能提供的功能几乎和 Camera1 一样，所以倒不如选择更加稳定的 Camera1。</li></ol><h2 id="13、结束语"><a href="#13、结束语" class="headerlink" title="13、结束语"></a>13、结束语</h2><p>本章到此结束，主要是介绍了 Camera2 的一些基础概念，让大家能够基本了解 Camera2 的工作流程和基础概念，并且知道使用 Camera2 能够做些什么。如果你对 Camera2 还是感到很陌生，不要紧，后续的教程会带领大家逐步深入了解 Camera2。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ol><li><a href="https://www.jianshu.com/p/9a2e66916fcb" target="_blank" rel="noopener">Android Camera2 教程 · 第一章 · 概览</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;0、引言&quot;&gt;&lt;a href=&quot;#0、引言&quot; class=&quot;headerlink&quot; title=&quot;0、引言&quot;&gt;&lt;/a&gt;0、引言&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;从 Android 5.0 开始，Google 引入了一套全新的相机框架 Camera2（android.
      
    
    </summary>
    
    
      <category term="AndroidCamera" scheme="https://frank2019.github.io/categories/AndroidCamera/"/>
    
    
      <category term="Android" scheme="https://frank2019.github.io/tags/Android/"/>
    
      <category term="Camera" scheme="https://frank2019.github.io/tags/Camera/"/>
    
      <category term="Camera2API" scheme="https://frank2019.github.io/tags/Camera2API/"/>
    
      <category term="Camera2" scheme="https://frank2019.github.io/tags/Camera2/"/>
    
  </entry>
  
  <entry>
    <title>Android_1_Camera相关代码和主要类</title>
    <link href="https://frank2019.github.io/2020/03/08/Android_1_Camera%E7%9B%B8%E5%85%B3%E4%BB%A3%E7%A0%81%E5%92%8C%E4%B8%BB%E8%A6%81%E7%B1%BB/"/>
    <id>https://frank2019.github.io/2020/03/08/Android_1_Camera%E7%9B%B8%E5%85%B3%E4%BB%A3%E7%A0%81%E5%92%8C%E4%B8%BB%E8%A6%81%E7%B1%BB/</id>
    <published>2020-03-08T13:45:55.055Z</published>
    <updated>2020-03-07T13:32:46.028Z</updated>
    
    <content type="html"><![CDATA[<h2 id><a href="#" class="headerlink" title></a></h2><h1 id="-1"><a href="#-1" class="headerlink" title></a></h1><h2 id="Application-framework："><a href="#Application-framework：" class="headerlink" title="Application framework："></a><strong>Application framework：</strong></h2><p>用于给APP提供访问hardware的Camera API2，通过binder来访问camera service。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">frameworks\base\core\java\android\hardware\camera2</span><br></pre></td></tr></table></figure><p>frameworks\av\camera 是camera framework与camera service IPC通讯的数据载体等等</p><h3 id="主要的类"><a href="#主要的类" class="headerlink" title="主要的类"></a>主要的类</h3><p>CameraManager:   </p><p>Camera2操作camera主要类      </p><p>CameraDeviceImpl:      </p><p>CameraCaptureSession：</p><h2 id="camera-service"><a href="#camera-service" class="headerlink" title="camera service"></a>camera service</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">frameworks\av\services\camera\libcameraservice</span><br></pre></td></tr></table></figure><p>主要类或文件</p><p>CameraDeviceClient.cpp      </p><p>CameraProviderManager.cpp      </p><p>Camera3Device.cpp</p><h2 id="AIDL"><a href="#AIDL" class="headerlink" title="AIDL"></a>AIDL</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">frameworks&#x2F;av&#x2F;camera&#x2F;aidl&#x2F;android&#x2F;hardware</span><br></pre></td></tr></table></figure><ul><li>基于Binder实现的一个用于让App fw代码访问natice fw代码的接口。。其中：</li></ul><p>​    (1) ICameraService 是相机服务的接口。用于请求连接、添加监听等。<br>​    (2) ICameraDeviceUser 是已打开的特定相机设备的接口。应用框架可通过它访问具体设备。<br>​    (3) ICameraServiceListener 和 ICameraDeviceCallbacks 分别是从 CameraService 和 CameraDevice 到应用框架的回调。</p><h2 id="cameraprovider"><a href="#cameraprovider" class="headerlink" title="cameraprovider"></a>cameraprovider</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hardware\interfaces\camera\provider\2.4</span><br></pre></td></tr></table></figure><h3 id="主要类"><a href="#主要类" class="headerlink" title="主要类"></a>主要类</h3><p>CameraProvider.cpp      <a href="mailto:android.hardware.camera.provider@2.4-service.rc">android.hardware.camera.provider@2.4-service.rc</a></p><h2 id="camera-HAL-interface"><a href="#camera-HAL-interface" class="headerlink" title="camera HAL interface"></a>camera HAL interface</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hardware\interfaces\camera\common\1.0      </span><br><span class="line">hardware\interfaces\camera\device\3.2      hardware\libhardware\include\hardware\camera3.h      hardware\libhardware\modules\camera\3_4</span><br></pre></td></tr></table></figure><h2 id="camera-HAL-implement"><a href="#camera-HAL-implement" class="headerlink" title="camera HAL implement"></a>camera HAL implement</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vendor\qcom\proprietary\camx\src\core</span><br></pre></td></tr></table></figure><p>主要类</p><p>camerahal3entry.cpp: camera hal   调用的入口      camxhal3.cpp: camera   hal接口主要实现类，capture_Request与capture_Result中转类，主要通过这个类来处理capture request与回调   capture result.      camxhaldevice.cpp:      camxhal3module.cpp</p><h2 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h2><p>vendor\qcom\proprietary\chi-cdk\vendor\node</p><p>核心算法都在这里</p><h4 id="-2"><a href="#-2" class="headerlink" title></a></h4><h2 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h2><ol><li><a href="https://www.jianshu.com/p/cfb1da9d4217" target="_blank" rel="noopener">Android Camera原理之camx hal架构</a></li><li><a href="https://www.cnblogs.com/blogs-of-lxl/p/10651611.html" target="_blank" rel="noopener">Android : Camera2/HAL3 框架分析</a></li><li><a href="http://www.bubuko.com/infodetail-3188907.html" target="_blank" rel="noopener">Camera CHI API</a></li><li><a href="https://www.cnblogs.com/KKKEr/p/11489237.html" target="_blank" rel="noopener">Android : Camera之CHI API</a></li></ol><ol><li><a href="https://blog.csdn.net/afei__/article/details/85960343" target="_blank" rel="noopener">CameraCharacteristics 详解</a></li><li><a href="https://www.cnblogs.com/blogs-of-lxl/p/10651611.html" target="_blank" rel="noopener">Android : Camera2/HAL3 框架分析</a></li><li><a href="https://www.cnblogs.com/KKKEr/p/11489237.html" target="_blank" rel="noopener">Android : Camera之CHI API</a></li><li><a href="https://www.jianshu.com/p/1332d3864f7c" target="_blank" rel="noopener">https://www.jianshu.com/p/1332d3864f7c</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id&gt;&lt;a href=&quot;#&quot; class=&quot;headerlink&quot; title&gt;&lt;/a&gt;&lt;/h2&gt;&lt;h1 id=&quot;-1&quot;&gt;&lt;a href=&quot;#-1&quot; class=&quot;headerlink&quot; title&gt;&lt;/a&gt;&lt;/h1&gt;&lt;h2 id=&quot;Application-framewo
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>AndroidCamera 1 Camera的架构</title>
    <link href="https://frank2019.github.io/2020/03/08/Android_1_Camera%E6%9E%B6%E6%9E%84/"/>
    <id>https://frank2019.github.io/2020/03/08/Android_1_Camera%E6%9E%B6%E6%9E%84/</id>
    <published>2020-03-08T13:45:55.053Z</published>
    <updated>2020-03-08T13:53:00.143Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Camera架构"><a href="#Camera架构" class="headerlink" title="Camera架构"></a>Camera架构</h2><p>Camera的架构与Android系统的整体架构保持一致，如下图所示:</p><p><img src="/2020/03/08/Android_1_Camera%E6%9E%B6%E6%9E%84/20170821154908066.dib" alt></p><h2 id="分层"><a href="#分层" class="headerlink" title="分层"></a>分层</h2><ul><li><p>Framework：<code>frameworks/base/core/java/android/hardware/Camera.java</code></p></li><li><p>Android Runtime：<code>frameworks/base/core/jni/android_hardware_Camera.cpp</code>  </p></li><li><p>C/C++ Libraries：</p><ul><li>Client：<pre><code>frameworks/av/camera/CameraBase.cppframeworks/av/camera/Camera.cppframeworks/av/camera/ICamera.cppframeworks/av/camera/aidl/android/hardware/ICamera.aidlframeworks/av/camera/aidl/android/hardware/ICameraClient.aidl</code></pre></li><li>Server：<pre><code>frameworks/av/camera/cameraserver/main_cameraserver.cppframeworks/av/services/camera/libcameraservice/CameraService.cppframeworks/av/services/camera/libcameraservice/api1/CameraClient.cppframeworks/av/camera/aidl/android/hardware/ICameraService.aidl</code></pre></li></ul></li><li><p>HAL：</p><ul><li>HAL 1：<pre><code>frameworks/av/services/camera/libcameraservice/device1/CameraHardwareInterface.h</code></pre></li><li>HAL 3：(主要学习了 HAL 1 的机制，HAL 3 以后再补充）<pre><code>frameworks/av/services/camera/libcameraservice/device3/***</code></pre></li></ul></li></ul><h2 id="C-S架构"><a href="#C-S架构" class="headerlink" title="C/S架构"></a>C/S架构</h2><p>Android Camera 框架是 一个 client/service 的架构。</p><ul><li>service进程</li></ul><p>属于服务端，由native c/c++代码实现,主要负责 通过HAL层和linux kernel中的camera driver交互。搜集camera driver 传递过来的数据，响应client端的请求</p><ul><li>client进程</li></ul><p>属于客户端，由java和native c/c++ 代码实现。可以看成应用程序。调用关系大致如下：</p><p>app –&gt;camera2 api framework –&gt;  android_hardware_camera.cpp –&gt;libcamera_client.so</p><h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><p>本系列的目标是从应用层 -&gt; framework -&gt;HAL –&gt;driver 详细的分析学习Android Camera系统。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Camera架构&quot;&gt;&lt;a href=&quot;#Camera架构&quot; class=&quot;headerlink&quot; title=&quot;Camera架构&quot;&gt;&lt;/a&gt;Camera架构&lt;/h2&gt;&lt;p&gt;Camera的架构与Android系统的整体架构保持一致，如下图所示:&lt;/p&gt;
&lt;p&gt;&lt;im
      
    
    </summary>
    
    
      <category term="AndroidCamera" scheme="https://frank2019.github.io/categories/AndroidCamera/"/>
    
    
      <category term="Android" scheme="https://frank2019.github.io/tags/Android/"/>
    
      <category term="Camera" scheme="https://frank2019.github.io/tags/Camera/"/>
    
      <category term="架构" scheme="https://frank2019.github.io/tags/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>智能指针shared_ptr</title>
    <link href="https://frank2019.github.io/2020/03/04/c++_1_shared_ptr/"/>
    <id>https://frank2019.github.io/2020/03/04/c++_1_shared_ptr/</id>
    <published>2020-03-04T14:38:16.690Z</published>
    <updated>2020-03-08T13:43:06.629Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>勿在浮沙筑高台</p></blockquote><p>本文的目标是掌握清楚 智能指针 shared_ptr 、unique_ptr 和weak_ptr 的用法， 涉及到的概念和理念。</p><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><h3 id="RAII-Resource-Acquisition-Is-Initialization"><a href="#RAII-Resource-Acquisition-Is-Initialization" class="headerlink" title="RAII(Resource Acquisition Is Initialization)"></a>RAII(Resource Acquisition Is Initialization)</h3><p>RAII 含义即是资源分配即初始化。 </p><ul><li><p>讲的是这样一个理念，将资源的管理放在一个类中，利用类的生命周期构造函数和析构函数来进行资源的管理和释放。用局部对象来表示资源。</p></li><li><p>这是c++ 编程中的最重要编程技法之一。</p></li><li><p>智能指针便是利用 RAII 的技术对普通的指针进行封装，这使得智能指针实质是一个对象，行为表现却像一个指针</p></li></ul><p>C++11 中提供了三种智能指针</p><p>分别是 shared_ptr , unique_ptr 和 weak_ptr 。</p><ol><li>shared_ptr 允许多个指针指向同一个对象，</li><li>unique_ptr 则“独占”所指向的对象，</li><li>weak_ptr 则是和share_ptr 相辅相成的伴随类</li></ol><h2 id="shared-ptr"><a href="#shared-ptr" class="headerlink" title="shared_ptr"></a>shared_ptr</h2><p> share_ptr是一个类，它产生的是一个类对象，而不是一个原生的指针对象，但是为了减少类对象与针对对象使用的差异性，所以share_ptr类故意重载了两种常见的指针操作符：  *和-&gt;。从而share_ptr与普通指针使用方式一样。简言之，就是share_ptr生成的一个包含类型指针容器对象，它封装了指针对象，对指针对象负全责，包括生成、释放等； </p><ol><li>shared_ptr多个智能指针可以指向相同对象；</li><li>能够自动释放所指向的对象</li><li>该对象和其相关资源会在“最后一个引用被销毁”时候释放。</li><li>对象创建完就应该直接交给智能指针管理；</li><li>shared_ptr 采用引用计数器，多个shared_ptr种的 T*ptr 指向同一内存区域(同一对象)，并共同维护同一个引用计数器。</li><li>初始化指针并将引用计数置为1;</li><li>当对象作为另一对象的副本而创建时，拷贝构造函数拷贝指针并增加与之相应的引用计数。</li><li>对一个对象进行赋值时，赋值操作符减少左操作数所指对象的引用计数（如果引用计数为减至0，则删除对象），并增加右操作数所指对象的引用计数；这是因为左侧的指针指向了右侧指针所指向的对象，因此右指针所指向的对象的引用计数加1。调用析构函数时，构造函数减少引用计数（如果引用计数减至0，则删除基础对象）。</li><li>share_ptr完美支持标准容器，并且不需要担心资源泄漏。而标准容易在使用指针对象时需要特别的小心，对指针需要额外的管理 。</li><li>特别需要注意的是，share_ptr的转型函数不能使用c++常用的转型函数，即static_cast，dynamic_cast，const_cast，而要使用static_pointer_cast，dynamic_pointer_cast，const_pointer_cast。原因有两个：static_cast，dynamic_cast，const_cast的功能是转换成对应的模版类型，即static_cast&lt;T*&gt;其实是转换成类型为T的指针；前面说了share_ptr生成的一个包含类型指针容器对象，使用简单的c++转型函数是将share_ptr对象转型为模版指针对象，这完全违背了使用share_ptr的初衷（除非你确确实实有这种需要！），导致转型的模版指针对象不能采用share_ptr进行管理。因为上面的两个原因：share_ptr为了支持转型，所以提供了类似的转型函数即static_pointer_cast<T>，从而使转型后仍然为shared_pointer对象，仍然对指针进行管理； </T></li></ol><h3 id="Member-functions"><a href="#Member-functions" class="headerlink" title="Member functions"></a>Member functions</h3><ul><li><p>构造函数      不谈拷贝构造的话，shared_ptr的基本构造方式有4种：</p><ul><li>无参数构造。</li><li>传入一个指针构造一个shared_ptr</li><li>传入一个指针和一个删除器构造一个shared_ptr。</li><li>传入一个指针、一个删除器以及一个allocator构造一个shared_ptr。</li><li>当然还有一些其他的，例如从auto_ptr从weak_ptr从null_ptr构造。</li></ul></li><li><p>析构函数   用来释放智能指针，至于是否释放智能指针所管理的对象，取决于成员use_count的值；</p><ul><li>如果use_count &gt; 1，则引用计数器减一；</li><li>如果use_count=1,则引用计数器置零，资源释放。</li><li>如果use_count=0,则说明此智能指针本来就没有指向对象。</li></ul></li><li><p><a href="http://www.cplusplus.com/reference/memory/shared_ptr/operator=/" target="_blank" rel="noopener"><strong>operator=</strong></a></p><p>赋值操作后，赋值前原来的 _refCount要自减 ， 计数器_refCount要做++ ；</p></li><li><p><a href="http://www.cplusplus.com/reference/memory/shared_ptr/swap/" target="_blank" rel="noopener"><strong>swap</strong></a></p><p>交换，使两个智能指针分别指向对方的对象。</p></li><li><p><a href="http://www.cplusplus.com/reference/memory/shared_ptr/reset/" target="_blank" rel="noopener"><strong>reset</strong></a>    复位操作，不再指向对象，原来所指向对象的_refCount要自减</p></li><li><p><a href="http://www.cplusplus.com/reference/memory/shared_ptr/get/" target="_blank" rel="noopener"><strong>get</strong></a>  获取对象的原始指针。</p></li><li><p><a href="http://www.cplusplus.com/reference/memory/shared_ptr/operator*/" target="_blank" rel="noopener"><strong>operator*</strong></a>  相当于*get()</p></li><li><p><a href="http://www.cplusplus.com/reference/memory/shared_ptr/operator->/" target="_blank" rel="noopener"><strong>operator-&gt;</strong></a>   可以像原指针一样，指向原指针的成员。</p></li><li><p><a href="http://www.cplusplus.com/reference/memory/shared_ptr/use_count/" target="_blank" rel="noopener"><strong>use_count</strong></a>  返回当前所指对象的引用计数。</p></li><li><p><a href="http://www.cplusplus.com/reference/memory/shared_ptr/unique/" target="_blank" rel="noopener"><strong>unique</strong></a>  检查Usecount() == 1</p></li><li><p>[<strong>operator bool</strong>](<a href="http://www.cplusplus.com/reference/memory/shared_ptr/operator" target="_blank" rel="noopener">http://www.cplusplus.com/reference/memory/shared_ptr/operator</a> bool/)  检查 <code>get()!=NULL</code> </p></li><li><p><a href="http://www.cplusplus.com/reference/memory/shared_ptr/owner_before/" target="_blank" rel="noopener"><strong>owner_before</strong></a></p><p>Owner-based ordering (public member function template )</p></li></ul><h3 id="Non-member-functions"><a href="#Non-member-functions" class="headerlink" title="Non-member functions"></a>Non-member functions</h3><ul><li><p><strong>swap</strong>   交换shared_ptr  所指对象</p></li><li><p><a href="http://www.cplusplus.com/reference/memory/shared_ptr/operators/" target="_blank" rel="noopener"><strong>relational operators</strong></a></p><p>Relational operators ==, !=, &lt;, &lt;=, &gt;, &gt;= (function template )</p></li><li><p>[<strong>ostream operator&lt;&lt;</strong>](<a href="http://www.cplusplus.com/reference/memory/shared_ptr/operator" target="_blank" rel="noopener">http://www.cplusplus.com/reference/memory/shared_ptr/operator</a>&lt;</p><p>跟原始指针的操作一样，流操作。</p></li><li><p><a href="http://www.cplusplus.com/reference/memory/make_shared/" target="_blank" rel="noopener"><strong>make_shared</strong></a></p><p>Make shared_ptr (function template )</p></li><li><p><a href="http://www.cplusplus.com/reference/memory/allocate_shared/" target="_blank" rel="noopener"><strong>allocate_shared</strong></a></p><p>Allocate shared_ptr (function template )</p></li><li><p><a href="http://www.cplusplus.com/reference/memory/static_pointer_cast/" target="_blank" rel="noopener"><strong>static_pointer_cast</strong></a></p><p>Static cast of shared_ptr (function template )</p></li><li><p><a href="http://www.cplusplus.com/reference/memory/dynamic_pointer_cast/" target="_blank" rel="noopener"><strong>dynamic_pointer_cast</strong></a></p><p>Dynamic cast of shared_ptr (function template )</p></li><li><p><a href="http://www.cplusplus.com/reference/memory/const_pointer_cast/" target="_blank" rel="noopener"><strong>const_pointer_cast</strong></a></p><p>Const cast of shared_ptr (function template )</p></li><li><p><a href="http://www.cplusplus.com/reference/memory/get_deleter/" target="_blank" rel="noopener"><strong>get_deleter</strong></a></p><p>Get deleter from shared_ptr (function template )</p></li></ul><h3 id="多线程问题"><a href="#多线程问题" class="headerlink" title="多线程问题"></a>多线程问题</h3><p>shared_ptr的线程安全的定义在boost的文档中有明确的说明：</p><ul><li><p>一个shared_ptr对象可以被多个线程同时read</p></li><li><p>两个shared_ptr对象，指向同一个raw指针，两个线程分别write这两个shared_ptr对象，是安全的。包括析构。</p></li><li><p>多个线程如果要对同一个shared_ptr对象读写，是线程不安全的</p></li></ul><p>也就是说，唯一需要注意的就是：多个线程中对同一个shared_ptr对象读写时需要加锁。但是即使是加锁也有技巧。比较好的方式是：</p><h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">C</span> &#123;</span><span class="keyword">int</span>* data;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; p1;</span><br><span class="line">  <span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; <span class="title">p2</span> <span class="params">(<span class="literal">nullptr</span>)</span></span>;</span><br><span class="line">  <span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; <span class="title">p3</span> <span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>)</span></span>;</span><br><span class="line">  <span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; <span class="title">p4</span> <span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>, <span class="built_in">std</span>::default_delete&lt;<span class="keyword">int</span>&gt;())</span></span>;</span><br><span class="line">  <span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; <span class="title">p5</span> <span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>, [](<span class="keyword">int</span>* p)&#123;<span class="keyword">delete</span> p;&#125;, <span class="built_in">std</span>::allocator&lt;<span class="keyword">int</span>&gt;())</span></span>;</span><br><span class="line">  <span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; <span class="title">p6</span> <span class="params">(p5)</span></span>;</span><br><span class="line">  <span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; <span class="title">p7</span> <span class="params">(<span class="built_in">std</span>::<span class="built_in">move</span>(p6))</span></span>;</span><br><span class="line">  <span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; <span class="title">p8</span> <span class="params">(<span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;<span class="keyword">int</span>&gt;(<span class="keyword">new</span> <span class="keyword">int</span>))</span></span>;</span><br><span class="line">  <span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;C&gt; <span class="title">obj</span> <span class="params">(<span class="keyword">new</span> C)</span></span>;</span><br><span class="line">  <span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; <span class="title">p9</span> <span class="params">(obj, obj-&gt;data)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"use_count:\n"</span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"p1: "</span> &lt;&lt; p1.use_count() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"p2: "</span> &lt;&lt; p2.use_count() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"p3: "</span> &lt;&lt; p3.use_count() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"p4: "</span> &lt;&lt; p4.use_count() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"p5: "</span> &lt;&lt; p5.use_count() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"p6: "</span> &lt;&lt; p6.use_count() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"p7: "</span> &lt;&lt; p7.use_count() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"p8: "</span> &lt;&lt; p8.use_count() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"p9: "</span> &lt;&lt; p9.use_count() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    </span><br><span class="line">   <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; foo = <span class="built_in">std</span>::make_shared&lt;<span class="keyword">int</span>&gt; (<span class="number">10</span>);</span><br><span class="line">  <span class="comment">// same as:</span></span><br><span class="line">  <span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; <span class="title">foo2</span> <span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">10</span>))</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> bar = <span class="built_in">std</span>::make_shared&lt;<span class="keyword">int</span>&gt; (<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> baz = <span class="built_in">std</span>::make_shared&lt;<span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&gt; (<span class="number">30</span>,<span class="number">40</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"*foo: "</span> &lt;&lt; *foo &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"*bar: "</span> &lt;&lt; *bar &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"*baz: "</span> &lt;&lt; baz-&gt;first &lt;&lt; <span class="string">' '</span> &lt;&lt; baz-&gt;second &lt;&lt; <span class="string">'\n'</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="std-weak-ptr"><a href="#std-weak-ptr" class="headerlink" title="std::weak_ptr"></a>std::weak_ptr</h2><p>引入是为了解决 std::share_ptr 的链接环问题。c++</p><p>一般结合强智能指针使用，它指向一个 shared_ptr 管理的对象. 进行该对象的内存管理的是强引用的 shared_ptr. weak_ptr只是提供了对管理对象的一个访问手段；weak_ptr 设计的目的是为配合 shared_ptr 而引入的一种智能指针来协助 shared_ptr 工作, 不会引起引用记数的增加或减少。</p><h2 id="std-unique-ptr"><a href="#std-unique-ptr" class="headerlink" title="std::unique_ptr"></a>std::unique_ptr</h2><p><a href="https://msdn.microsoft.com/zh-cn/library/ee410601.aspx" target="_blank" rel="noopener">unique_ptr</a> 不共享它的指针。它无法复制到其他 unique_ptr，无法通过值传递到函数，也无法用于需要副本的任何标准模板库 (STL) 算法。只能移动</p><h2 id="手册"><a href="#手册" class="headerlink" title="手册"></a>手册</h2><ol><li><a href="http://www.cplusplus.com/reference/memory/shared_ptr/" target="_blank" rel="noopener">http://www.cplusplus.com/reference/memory/shared_ptr/</a></li><li><a href="http://c.biancheng.net/view/430.html" target="_blank" rel="noopener">http://c.biancheng.net/view/430.html</a></li></ol><h2 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h2><p>智能指针shared_ptr的实现</p><p>主要的问题</p><ol><li>shared_ptr 整体是如何实现的；</li><li>shared_ptr  计数器的实现；</li><li>shared_ptr   怎么实现-&gt; 操作，访问所指向对象的成员就像访问本身的成员一样。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;勿在浮沙筑高台&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;本文的目标是掌握清楚 智能指针 shared_ptr 、unique_ptr 和weak_ptr 的用法， 涉及到的概念和理念。&lt;/p&gt;
&lt;h2 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; 
      
    
    </summary>
    
    
      <category term="C++基础系列" scheme="https://frank2019.github.io/categories/C-%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="C++" scheme="https://frank2019.github.io/tags/C/"/>
    
      <category term="智能指针" scheme="https://frank2019.github.io/tags/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/"/>
    
      <category term="shared_ptr" scheme="https://frank2019.github.io/tags/shared-ptr/"/>
    
      <category term="preview" scheme="https://frank2019.github.io/tags/preview/"/>
    
  </entry>
  
  <entry>
    <title>hexo及next配置进阶-定制化博客</title>
    <link href="https://frank2019.github.io/2020/03/01/hexo_3_hexo%E5%8F%8Anext%E9%85%8D%E7%BD%AE%E8%BF%9B%E9%98%B6/"/>
    <id>https://frank2019.github.io/2020/03/01/hexo_3_hexo%E5%8F%8Anext%E9%85%8D%E7%BD%AE%E8%BF%9B%E9%98%B6/</id>
    <published>2020-03-01T02:15:13.509Z</published>
    <updated>2020-03-01T08:47:51.128Z</updated>
    
    <content type="html"><![CDATA[<h2 id="博客名字体的配置"><a href="#博客名字体的配置" class="headerlink" title="博客名字体的配置"></a>博客名字体的配置</h2><p>目标是把博客的名字的字体更改。</p><p>这部分的设置可以在theme的配置种修改。</p><p>themes\next_config.yml</p><p>如下，我将字体改为华文隶书。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># Font settings for site title (.site-title).</span></span><br><span class="line"><span class="attr">title:</span></span><br><span class="line">  <span class="attr">external:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">family:</span> <span class="string">华文隶书</span> <span class="comment">#Roboto Slab</span></span><br><span class="line">  <span class="attr">size:</span> <span class="number">4</span></span><br></pre></td></tr></table></figure><p>依次类推，比如文章标题 正文等等的字体和大小的设置也可以在这部分配置种实现。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;博客名字体的配置&quot;&gt;&lt;a href=&quot;#博客名字体的配置&quot; class=&quot;headerlink&quot; title=&quot;博客名字体的配置&quot;&gt;&lt;/a&gt;博客名字体的配置&lt;/h2&gt;&lt;p&gt;目标是把博客的名字的字体更改。&lt;/p&gt;
&lt;p&gt;这部分的设置可以在theme的配置种修改。&lt;/
      
    
    </summary>
    
    
      <category term="hexo" scheme="https://frank2019.github.io/categories/hexo/"/>
    
    
  </entry>
  
  <entry>
    <title>关于自我提升方法论</title>
    <link href="https://frank2019.github.io/2020/02/29/001.%E8%87%AA%E6%88%91%E6%8F%90%E5%8D%87%E6%96%B9%E6%B3%95%E8%AE%BA/"/>
    <id>https://frank2019.github.io/2020/02/29/001.%E8%87%AA%E6%88%91%E6%8F%90%E5%8D%87%E6%96%B9%E6%B3%95%E8%AE%BA/</id>
    <published>2020-02-29T02:20:50.145Z</published>
    <updated>2020-02-29T02:48:06.494Z</updated>
    
    <content type="html"><![CDATA[<p>在这个日新月异的时代，似乎每天如果不有点进步似乎都不好意思出门见人，</p><p>也更不好意思，谈理想和人生。</p><p>汤铭有云:苟日新,日日新,又日新!</p><p>你我或许是稚子顽童，青年才俊 亦或许是老骥伏枥，均可意气风发，志在千里。</p><p>但千里之行，终须始于足下，</p><p>万丈高楼也需凭地基而起，</p><p>像大海一样的事业也是靠江河小流聚势而成。</p><p>《大学》里说： 物有本末，事有终始，知所先后，则近道矣。</p><p>本系列的目标即是研究，学习之道，自我提升之方法论。</p><p>欢迎一起参禅悟道，勇攀高峰！</p><p>我是晓光，希望能和你相伴。公众号：猫爪在线</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在这个日新月异的时代，似乎每天如果不有点进步似乎都不好意思出门见人，&lt;/p&gt;
&lt;p&gt;也更不好意思，谈理想和人生。&lt;/p&gt;
&lt;p&gt;汤铭有云:苟日新,日日新,又日新!&lt;/p&gt;
&lt;p&gt;你我或许是稚子顽童，青年才俊 亦或许是老骥伏枥，均可意气风发，志在千里。&lt;/p&gt;
&lt;p&gt;但千里之
      
    
    </summary>
    
    
      <category term="自我提升方法论" scheme="https://frank2019.github.io/categories/%E8%87%AA%E6%88%91%E6%8F%90%E5%8D%87%E6%96%B9%E6%B3%95%E8%AE%BA/"/>
    
    
  </entry>
  
  <entry>
    <title>写博客的好处</title>
    <link href="https://frank2019.github.io/2020/02/28/hexo_1_%E5%86%99%E5%8D%9A%E5%AE%A2%E7%9A%84%E5%A5%BD%E5%A4%84/"/>
    <id>https://frank2019.github.io/2020/02/28/hexo_1_%E5%86%99%E5%8D%9A%E5%AE%A2%E7%9A%84%E5%A5%BD%E5%A4%84/</id>
    <published>2020-02-28T00:27:54.330Z</published>
    <updated>2020-03-01T08:44:22.167Z</updated>
    
    <content type="html"><![CDATA[<h3 id><a href="#" class="headerlink" title></a></h3><p>古人说:  格物、致知、诚意、正心 ， 修身、齐家、治国、平天下 。</p><p>古人又说：   立德、立功、立言 ，三不朽。  写博客也算立言的开始吧。</p><p>我觉得这是金玉良言啊。</p><p>那么咱们谈谈，我觉得写博客的好处具体有那些？</p><ol><li>教学相长</li><li>加深对技术和概念的理解；</li><li>提高思维能力，和逻辑能力；</li><li>提高沟通能力，每一篇文章都是一次自我沟通的开始。</li><li>方便查阅以后用的到；</li><li>可以看到多年之前的文章/想法/当时对技术的理解。</li><li>获取阅读量，得到认可，提高知名度；</li><li>结交志同道合的人，结伴前行；</li><li>提高写作水平,文案水平；</li><li>为自己的人生留下只言片语；</li><li>碎片化学习；</li></ol><p>如果你对独立博客感兴趣，可以加入群聊。一起交流</p><p> 独立博客爱好群QQ群: 1071329826 </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id&gt;&lt;a href=&quot;#&quot; class=&quot;headerlink&quot; title&gt;&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;古人说:  格物、致知、诚意、正心 ， 修身、齐家、治国、平天下 。&lt;/p&gt;
&lt;p&gt;古人又说：   立德、立功、立言 ，三不朽。  写博客也算立言的开始吧。&lt;/p&gt;
&lt;
      
    
    </summary>
    
    
      <category term="hexo" scheme="https://frank2019.github.io/categories/hexo/"/>
    
    
  </entry>
  
  <entry>
    <title>基于hexo免费搭建个人独立博客</title>
    <link href="https://frank2019.github.io/2020/02/27/hexo_2_%E5%9F%BA%E4%BA%8Ehexo%E5%85%8D%E8%B4%B9%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E7%8B%AC%E7%AB%8B%E5%8D%9A%E5%AE%A2/"/>
    <id>https://frank2019.github.io/2020/02/27/hexo_2_%E5%9F%BA%E4%BA%8Ehexo%E5%85%8D%E8%B4%B9%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E7%8B%AC%E7%AB%8B%E5%8D%9A%E5%AE%A2/</id>
    <published>2020-02-27T13:32:25.820Z</published>
    <updated>2020-03-02T00:12:16.641Z</updated>
    
    <content type="html"><![CDATA[<h3 id="本系列目标"><a href="#本系列目标" class="headerlink" title="本系列目标"></a>本系列目标</h3><p>免费搭建一个静态独立博客。</p><p>关键词： 免费，静态独立博客。</p><h3 id="GitHub创建个人仓库"><a href="#GitHub创建个人仓库" class="headerlink" title="GitHub创建个人仓库"></a>GitHub创建个人仓库</h3><p>免费的问题是通过GitHub解决的，Github有提供相关的免费服务，我们基于此可以构建免费的静态独立博客。</p><ol><li>登录到 GitHub ，</li><li>如果没有 GitHub 帐号，请使用你的邮箱注册 GitHub 帐号：<a href="https://github.com/join?source=header-home" target="_blank" rel="noopener">https://github.com/join?source=header-home</a></li><li>登录成功之后，点击 GitHub 中的 New repository 创建新仓库，仓库名应该为：<strong>用户名</strong>.github.io 。这里<strong>用户名</strong>使用你的 GitHub 帐号名称代替，这是固定写法。 </li></ol><h3 id="使用git配置key免密码访问"><a href="#使用git配置key免密码访问" class="headerlink" title="使用git配置key免密码访问"></a>使用git配置key免密码访问</h3><p>Git 是目前世界上最先进的分布式版本控制系统（没有之一）。这是使用 Git 的目的是将我们的网站部署到服务器（GitHub）上面去。</p><h4 id="安装Git"><a href="#安装Git" class="headerlink" title="安装Git"></a>安装Git</h4><p>推荐: <a href="https://gitforwindows.org/" target="_blank" rel="noopener">https://gitforwindows.org/</a></p><p> 安装好 Git 后，只需要进行下面的配置即可 </p><h4 id="配置信息"><a href="#配置信息" class="headerlink" title="配置信息"></a>配置信息</h4><p>在终端进行操作，设置 user.name 和 user.email 配置信息，我这里设置为全局。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name <span class="string">"你的GitHub用户名"</span></span><br><span class="line">git config --global user.email <span class="string">"你的GitHub注册邮箱"</span></span><br></pre></td></tr></table></figure><h4 id="生成密钥"><a href="#生成密钥" class="headerlink" title="生成密钥"></a>生成密钥</h4><p>通过注册的邮箱生成 ssh 密钥文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C <span class="string">"你的GitHub注册邮箱"</span></span><br></pre></td></tr></table></figure><p> 然后直接三个回车即可，默认不需要设置密码。最后得到了两个文件：<code>id_rsa</code>和<code>id_rsa.pub</code>。 </p><p> 打开 <code>id_rsa.pub 文件</code>，将里面的内容全部复制。 </p><h4 id="配置到GitHub"><a href="#配置到GitHub" class="headerlink" title="配置到GitHub"></a>配置到GitHub</h4><p>登录自己的Github，选择 setting -&gt; SSH and GPG keys </p><p>在SSH keys 项中 点击 New SSH key 按钮</p><p>Title可以自己定义， key中 拷贝入刚才在<code>id_rsa.pub 文件</code> 拷贝的内容</p><p>点击Add SSH key 配置完成。</p><h4 id="测试GitHub-SSH"><a href="#测试GitHub-SSH" class="headerlink" title="测试GitHub SSH"></a>测试GitHub SSH</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure><p>显示如下代表OK</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">λ ssh -T git@github.com</span><br><span class="line">Hi frank2019! You&#39;ve successfully authenticated, but GitHub does not provide shell access</span><br></pre></td></tr></table></figure><h3 id="Hexo安装"><a href="#Hexo安装" class="headerlink" title="Hexo安装"></a>Hexo安装</h3><h4 id="安装Node-js"><a href="#安装Node-js" class="headerlink" title="安装Node.js"></a>安装Node.js</h4><p>Hexo 基于 Node.js，因此需要先安装 Node.js；</p><p>你可以在这里进行对应电脑版本的下载：<a href="https://nodejs.org/en/download/" target="_blank" rel="noopener">https://nodejs.org/en/download/</a></p><h4 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h4><p>Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。</p><p>所有必备的应用程序安装完成后，即可使用 npm 安装 Hexo。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure><h3 id="Hexo使用"><a href="#Hexo使用" class="headerlink" title="Hexo使用"></a>Hexo使用</h3><p>安装好 Hexo 后，马上就能使用了。首先初始化博客，输入：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo <span class="keyword">init</span> myBlog</span><br></pre></td></tr></table></figure><p> 接下来，进入文件夹 <code>myBlog</code>,输入 </p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo s</span><br></pre></td></tr></table></figure><p>此时，在本地的你的博客已经运行起来，可以在浏览器中查看</p><p> 然后，打开浏览器输入地址： </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">localhost:4000</span><br></pre></td></tr></table></figure><p>执行到这里事实上博客就已经搭建好了，接下来就是去完善它。</p><p>注意：下面的命令都是在 <code>myBlog</code>文件里进行操作的。</p><h3 id="添加文章"><a href="#添加文章" class="headerlink" title="添加文章"></a>添加文章</h3><h4 id="1、直接导入文章"><a href="#1、直接导入文章" class="headerlink" title="1、直接导入文章"></a>1、直接导入文章</h4><p>你可以将你平时写的文章直接导入到 <code>_posts</code>  文件夹里，注意文章类型得是 <code>md</code>格式。</p><h4 id="2、写新文章"><a href="#2、写新文章" class="headerlink" title="2、写新文章"></a>2、写新文章</h4><p>你可以执行下列命令来创建一篇新文章。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new [layout] &lt;title&gt;</span><br></pre></td></tr></table></figure><h4 id="3、生成网页"><a href="#3、生成网页" class="headerlink" title="3、生成网页"></a>3、生成网页</h4><p>使用 Hexo 生成静态文件快速而且简单。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo generate</span><br><span class="line">//简写 hexo g</span><br></pre></td></tr></table></figure><h3 id="启动服务预览文章"><a href="#启动服务预览文章" class="headerlink" title="启动服务预览文章"></a>启动服务预览文章</h3><p> 输入以下命令以启动服务器，你的网站会在 <code>http://localhost:4000</code> 下启动。在服务器启动期间，Hexo 会监视文件变动并自动更新，无须重启服务器。 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo server</span><br></pre></td></tr></table></figure><p> 如果你想要更改端口，或是在执行时遇到了 <code>EADDRINUSE</code> 错误，可以在执行时使用 <code>-p</code> 选项指定其他端口，如下： </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server -p 5000</span><br></pre></td></tr></table></figure><h3 id="小总结"><a href="#小总结" class="headerlink" title="小总结"></a>小总结</h3><p>1、hexo init  [folder]       初始化本地文件夹为hexo项目</p><p>2、hexo new “我的博客文章”   #新建文章</p><p>3、hexo generate         #生成网页</p><p>4、hexo server     #启动服务预览</p><h3 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h3><p>Hexo 提供了快速方便的一键部署功能，只需一条命令就能将网站部署到服务器上。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p> 在开始之前，必须先在 <code>_config.yml</code> 中修改参数，一个正确的部署配置中至少要有 <code>type</code> 参数，例如： </p><p> 在<code>_config.yml</code>中进行修改。 </p><p>修改其中的deploy 为自己的内容。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Extensions</span></span><br><span class="line"><span class="comment">## Plugins: https://hexo.io/plugins/</span></span><br><span class="line"><span class="comment">## Themes: https://hexo.io/themes/</span></span><br><span class="line">theme: landscape</span><br><span class="line"></span><br><span class="line"><span class="comment"># Deployment</span></span><br><span class="line"><span class="comment">## Docs: https://hexo.io/docs/deployment.html</span></span><br><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: https://github.com/frank2019/frank2019.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure><p>这一步的目的是将 Hexo 与 GitHub 进行关联。</p><p>配置好后通过</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo d</span><br></pre></td></tr></table></figure><p> 命令，稍等片刻，网站就已经部署好了，可以在浏览器输入<code>你的GitHub名称.github.io</code>，这样一个免费的博客就已经搭建好了。 </p><p>我的博客是</p><p><a href="https://frank2019.github.io/">https://frank2019.github.io/</a></p><h3 id="Hexo-主题"><a href="#Hexo-主题" class="headerlink" title="Hexo 主题"></a>Hexo 主题</h3><p>hexo 默认的主题可能显得有点呆板，你可以在 <a href="https://hexo.io/themes/index.html进行主题的挑选更换。将下好的主题安放在`themes`文件夹内，同时在`_config.yml`中进行主题修改就好了。" target="_blank" rel="noopener">https://hexo.io/themes/index.html进行主题的挑选更换。将下好的主题安放在`themes`文件夹内，同时在`_config.yml`中进行主题修改就好了。</a></p><p> 一般大佬们提供的主题都会提供文档说明，按照说明进行简单的设置就能拥有一个酷炫的页面了。 </p><p>推荐链接：</p><p><a href="https://www.hexothe.me/" target="_blank" rel="noopener">排名前 10 的 Hexo 主题</a></p><h3 id="出错处理"><a href="#出错处理" class="headerlink" title="出错处理"></a>出错处理</h3><h4 id="ERROR-Deployer-not-found-git"><a href="#ERROR-Deployer-not-found-git" class="headerlink" title="ERROR Deployer not found: git"></a>ERROR Deployer not found: git</h4><p> hexo d<br> ERROR Deployer not found: git </p><p>执行以下命令即可</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install --save hexo-deployer-git</span><br></pre></td></tr></table></figure><h4 id="Package-cheerio-is-not-installed"><a href="#Package-cheerio-is-not-installed" class="headerlink" title="Package cheerio is not installed."></a>Package cheerio is not installed.</h4><p>INFO  Checking dependencies<br>ERROR Package cheerio is not installed.<br>ERROR Please install the missing dependencies from the root directory of your Hexo site.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ npm install cheerio</span><br><span class="line">npm WARN npm npm does not support Node.js v12.16.1</span><br><span class="line">npm WARN npm You should probably upgrade to a newer version of node as we</span><br><span class="line">npm WARN npm can<span class="string">'t make any promises that npm will work with this version.</span></span><br><span class="line"><span class="string">npm WARN npm Supported releases of Node.js are the latest release of 6, 8, 9, 10, 11.</span></span><br><span class="line"><span class="string">npm WARN npm You can find the latest version at https://nodejs.org/</span></span><br><span class="line"><span class="string">npm WARN optional SKIPPING OPTIONAL DEPENDENCY: fsevents@2.1.2 (node_modules\fsevents):</span></span><br><span class="line"><span class="string">npm WARN notsup SKIPPING OPTIONAL DEPENDENCY: Unsupported platform for fsevents@2.1.2: wanted &#123;"os":"darwin","arch":"any"&#125; (current: &#123;"os":"win32","arch":"x64"&#125;)</span></span><br><span class="line"><span class="string">npm WARN optional SKIPPING OPTIONAL DEPENDENCY: fsevents@1.2.11 (node_modules\nunjucks\node_modules\fsevents):</span></span><br><span class="line"><span class="string">npm WARN notsup SKIPPING OPTIONAL DEPENDENCY: Unsupported platform for fsevents@1.2.11: wanted &#123;"os":"darwin","arch":"any"&#125; (current: &#123;"os":"win32","arch":"x64"&#125;)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">+ cheerio@1.0.0-rc.3</span></span><br><span class="line"><span class="string">added 16 packages from 47 contributors in 5.886s</span></span><br></pre></td></tr></table></figure><hr><p>动手试一下吧！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;本系列目标&quot;&gt;&lt;a href=&quot;#本系列目标&quot; class=&quot;headerlink&quot; title=&quot;本系列目标&quot;&gt;&lt;/a&gt;本系列目标&lt;/h3&gt;&lt;p&gt;免费搭建一个静态独立博客。&lt;/p&gt;
&lt;p&gt;关键词： 免费，静态独立博客。&lt;/p&gt;
&lt;h3 id=&quot;GitHub创建个
      
    
    </summary>
    
    
      <category term="hexo" scheme="https://frank2019.github.io/categories/hexo/"/>
    
    
      <category term="hexo" scheme="https://frank2019.github.io/tags/hexo/"/>
    
      <category term="独立博客" scheme="https://frank2019.github.io/tags/%E7%8B%AC%E7%AB%8B%E5%8D%9A%E5%AE%A2/"/>
    
      <category term="next" scheme="https://frank2019.github.io/tags/next/"/>
    
  </entry>
  
  <entry>
    <title>我是谁?</title>
    <link href="https://frank2019.github.io/2020/02/27/who-am-I/"/>
    <id>https://frank2019.github.io/2020/02/27/who-am-I/</id>
    <published>2020-02-27T13:32:25.811Z</published>
    <updated>2020-03-02T00:14:30.955Z</updated>
    
    <content type="html"><![CDATA[<h3 id="我是谁"><a href="#我是谁" class="headerlink" title="我是谁?"></a>我是谁?</h3><p>很高兴大家来到这里，我是‘东胜神州’博客</p><ul><li><p>在这里我会坚持优质的内容</p></li><li><p>坚持价值投资 </p></li><li><p>坚持长期主义 </p></li><li><p>热爱美食 旅行 编程  参禅悟道</p></li><li><p>坚持成就你我的梦想 </p></li><li><p>坚持知行合一(实践类的话题坚持打磨出个不错的(或实习)产品，有所得)</p></li><li><p>如切如磋,如琢如磨</p></li></ul><p>欢迎大家多提宝贵意见！  十分感谢!</p><h3 id="交流学习"><a href="#交流学习" class="headerlink" title="交流学习"></a>交流学习</h3><ul><li>独立博客爱好群QQ群: 1071329826 </li></ul><h3 id="我可以为你做什么"><a href="#我可以为你做什么" class="headerlink" title="我可以为你做什么?"></a>我可以为你做什么?</h3><h3 id="欢迎合作"><a href="#欢迎合作" class="headerlink" title="欢迎合作"></a>欢迎合作</h3><p>开放包容 锐意进取 合作共赢!</p><p>有好的想法或创意欢迎加我！</p><p>我的公众号:  猫爪在线</p><p>Email: <a href="mailto:frank2019@yeah.net">frank2019@yeah.net</a></p><p>QQ:454052811</p><p><img src="/2020/02/27/who-am-I/le.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;我是谁&quot;&gt;&lt;a href=&quot;#我是谁&quot; class=&quot;headerlink&quot; title=&quot;我是谁?&quot;&gt;&lt;/a&gt;我是谁?&lt;/h3&gt;&lt;p&gt;很高兴大家来到这里，我是‘东胜神州’博客&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;在这里我会坚持优质的内容&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
      
    
    </summary>
    
    
      <category term="我是谁" scheme="https://frank2019.github.io/categories/%E6%88%91%E6%98%AF%E8%B0%81/"/>
    
    
      <category term="关于博客" scheme="https://frank2019.github.io/tags/%E5%85%B3%E4%BA%8E%E5%8D%9A%E5%AE%A2/"/>
    
      <category term="东胜神州" scheme="https://frank2019.github.io/tags/%E4%B8%9C%E8%83%9C%E7%A5%9E%E5%B7%9E/"/>
    
      <category term="我们的理念" scheme="https://frank2019.github.io/tags/%E6%88%91%E4%BB%AC%E7%9A%84%E7%90%86%E5%BF%B5/"/>
    
  </entry>
  
  <entry>
    <title>Dear ImGui library简介及入门</title>
    <link href="https://frank2019.github.io/2020/02/27/Dear%20ImGui%20library%E7%AE%80%E4%BB%8B%E5%8F%8A%E5%85%A5%E9%97%A8/"/>
    <id>https://frank2019.github.io/2020/02/27/Dear%20ImGui%20library%E7%AE%80%E4%BB%8B%E5%8F%8A%E5%85%A5%E9%97%A8/</id>
    <published>2020-02-27T13:32:25.785Z</published>
    <updated>2020-02-24T14:40:53.921Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Dear-ImGui-library-简介"><a href="#Dear-ImGui-library-简介" class="headerlink" title="Dear ImGui library  简介"></a>Dear ImGui library  简介</h2><p>作为开发人员，我们都面临着向程序引入图形界面的痛苦。传统的GUI库增加了一定程度的复杂性，如果您正在制作用于调试的工具，则可能不需要这些复杂性。在这里，我们提供了一个库，使创建记录器、配置文件器、调试器甚至整个游戏编辑器成为可能。这里介绍的整个示例可在Github上查阅。</p><h3 id="Dear-ImGui"><a href="#Dear-ImGui" class="headerlink" title="Dear ImGui?"></a>Dear ImGui?</h3><p><a href="https://github.com/ocornut/imgui" target="_blank" rel="noopener">Dear ImGui</a> 是一个令人惊叹的C++ UI 库，主要应用在游戏开发。该项目是开源软件，基于MIT license。Dear ImGui专注于简单性和生产力，使用的是<a href="https://caseymuratori.com/blog_0001" target="_blank" rel="noopener">Inmediate Mode GUI paradigm</a>。</p><p>即时模式GUI不同于传统的保留模式界面，因为小部件是在每个帧上创建和绘制的，而传统的方法是首先创建小部件并向其添加回调。这种模式的一些好处是您的UI“更接近”您的数据，并且它允许快速原型化。</p><p>Dear ImGui主要设计用于开发人员在内容创建和调试工具中使用..它是渲染器不可知论的方式，您必须提供工具来呈现数据，但它非常容易集成到您自己的代码中，因为它有多个绑定的不同窗口和事件处理库（如GLFW，SDL2和GLUT）和多个渲染器（如OpenGL，DirectX和Vulkan）。</p><p>Dear ImGui配备了许多小部件，如窗口、标签、输入框、进度条、按钮、滑块、树等。你可以在下面的图片中看到一些例子。</p><p>![](Dear ImGui library简介及入门/conan-imgui-widgets.gif)</p><h3 id="在应用中集成Dear-ImGui"><a href="#在应用中集成Dear-ImGui" class="headerlink" title="在应用中集成Dear ImGui"></a>在应用中集成Dear ImGui</h3><p>ImGui的典型用途是当您已经有了一个启用3D管道的应用程序，如内容创建或游戏开发工具，您希望在其中添加GUI。让我们看看在我们的应用程序中集成ImGui是多么容易。我们的示例应用程序使用OpenGL3呈现三角形。我们将使用GLFW管理窗口创建和事件处理。由于ImGui独立于渲染系统和平台，我们必须为我们的渲染系统引入一些绑定。幸运的是， Dear ImGui的设计中包含预先的绑定，比如我们在使用的Dear ImGui v1.69中我们包含以下头文件:</p><ul><li><a href="https://github.com/ocornut/imgui/blob/v1.69/examples/imgui_impl_opengl3.cpp" target="_blank" rel="noopener">imgui_impl_opengl3.cpp</a></li><li><a href="https://github.com/ocornut/imgui/blob/v1.69/examples/imgui_impl_opengl3.h" target="_blank" rel="noopener">imgui_impl_opengl3.h</a></li><li><a href="https://github.com/ocornut/imgui/blob/v1.69/examples/imgui_impl_glfw.cpp" target="_blank" rel="noopener">imgui_impl_glfw.cpp</a></li><li><a href="https://github.com/ocornut/imgui/blob/v1.69/examples/imgui_impl_glfw.h" target="_blank" rel="noopener">imgui_impl_glfw.h</a></li></ul><p>使此工作的最小代码在main.cpp中。首先，初始化用于呈现的窗口，然后必须初始化DearImGui上下文以及助手平台和Renderer绑定。如果您愿意，也可以更改渲染样式。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Setup Dear ImGui context</span></span><br><span class="line">IMGUI_CHECKVERSION();</span><br><span class="line">ImGui::CreateContext();</span><br><span class="line">ImGuiIO &amp;io = ImGui::GetIO();</span><br><span class="line"><span class="comment">// Setup Platform/Renderer bindings</span></span><br><span class="line">ImGui_ImplGlfw_InitForOpenGL(window, <span class="literal">true</span>);</span><br><span class="line">ImGui_ImplOpenGL3_Init(glsl_version);</span><br><span class="line"><span class="comment">// Setup Dear ImGui style</span></span><br><span class="line">ImGui::StyleColorsDark();</span><br></pre></td></tr></table></figure><p>然后，您进入主应用程序循环，在那里您可以清楚地看到与经典保留模式GUI的区别。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (!glfwWindowShouldClose(window))</span><br><span class="line">&#123;</span><br><span class="line">    glfwPollEvents();</span><br><span class="line">    glClearColor(<span class="number">0.45f</span>, <span class="number">0.55f</span>, <span class="number">0.60f</span>, <span class="number">1.00f</span>);</span><br><span class="line">    glClear(GL_COLOR_BUFFER_BIT);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// feed inputs to dear imgui, start new frame</span></span><br><span class="line">    ImGui_ImplOpenGL3_NewFrame();</span><br><span class="line">    ImGui_ImplGlfw_NewFrame();</span><br><span class="line">    ImGui::NewFrame();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// rendering our geometries</span></span><br><span class="line">    triangle_shader.use();</span><br><span class="line">    glBindVertexArray(vao);</span><br><span class="line">    glDrawElements(GL_TRIANGLES, <span class="number">3</span>, GL_UNSIGNED_INT, <span class="number">0</span>);</span><br><span class="line">    glBindVertexArray(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// render your GUI</span></span><br><span class="line">    ImGui::Begin(<span class="string">"Demo window"</span>);</span><br><span class="line">    ImGui::Button(<span class="string">"Hello!"</span>);</span><br><span class="line">    ImGui::End();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Render dear imgui into screen</span></span><br><span class="line">    ImGui::Render();</span><br><span class="line">    ImGui_ImplOpenGL3_RenderDrawData(ImGui::GetDrawData());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> display_w, display_h;</span><br><span class="line">    glfwGetFramebufferSize(window, &amp;display_w, &amp;display_h);</span><br><span class="line">    glViewport(<span class="number">0</span>, <span class="number">0</span>, display_w, display_h);</span><br><span class="line">    glfwSwapBuffers(window);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，当循环结束时，做一些清理。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ImGui_ImplOpenGL3_Shutdown();</span><br><span class="line">ImGui_ImplGlfw_Shutdown();</span><br><span class="line">ImGui::DestroyContext();</span><br></pre></td></tr></table></figure><p>所以，这就是我们得到的：</p><p><img src="/2020/02/27/Dear%20ImGui%20library%E7%AE%80%E4%BB%8B%E5%8F%8A%E5%85%A5%E9%97%A8/conan-imgui-hello-world.gif" alt></p><p>例如，让我们说，我们想要改变三角形的位置/方向和颜色。这就像调用一些滑块和选色器，并通过着色器将数据传递给三角形一样简单：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// render your GUI</span></span><br><span class="line">ImGui::Begin(<span class="string">"Triangle Position/Color"</span>);</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">float</span> rotation = <span class="number">0.0</span>;</span><br><span class="line">ImGui::SliderFloat(<span class="string">"rotation"</span>, &amp;rotation, <span class="number">0</span>, <span class="number">2</span> * PI);</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">float</span> translation[] = &#123;<span class="number">0.0</span>, <span class="number">0.0</span>&#125;;</span><br><span class="line">ImGui::SliderFloat2(<span class="string">"position"</span>, translation, <span class="number">-1.0</span>, <span class="number">1.0</span>);</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">float</span> color[<span class="number">4</span>] = &#123; <span class="number">1.0f</span>,<span class="number">1.0f</span>,<span class="number">1.0f</span>,<span class="number">1.0f</span> &#125;;</span><br><span class="line"><span class="comment">// pass the parameters to the shader</span></span><br><span class="line">triangle_shader.setUniform(<span class="string">"rotation"</span>, rotation);</span><br><span class="line">triangle_shader.setUniform(<span class="string">"translation"</span>, translation[<span class="number">0</span>], translation[<span class="number">1</span>]);</span><br><span class="line"><span class="comment">// color picker</span></span><br><span class="line">ImGui::ColorEdit3(<span class="string">"color"</span>, color);</span><br><span class="line"><span class="comment">// multiply triangle's color with this color</span></span><br><span class="line">triangle_shader.setUniform(<span class="string">"color"</span>, color[<span class="number">0</span>], color[<span class="number">1</span>], color[<span class="number">2</span>]);</span><br></pre></td></tr></table></figure><p><img src="/2020/02/27/Dear%20ImGui%20library%E7%AE%80%E4%BB%8B%E5%8F%8A%E5%85%A5%E9%97%A8/conan-imgui-triangle-rotate-color.gif" alt></p><p>还有一些基本的绘图工具。</p><p>![](Dear ImGui library简介及入门/conan-imgui-logo.png)</p><p>如果您想探索不同的库小部件和选项，最好的方法是调用ImGui：ShowDemoWindow（）并查看不同的示例。</p><h3 id="Setting-up-a-project-with-Conan"><a href="#Setting-up-a-project-with-Conan" class="headerlink" title="Setting up a project with Conan"></a>Setting up a project with Conan</h3><p>使用Connan建立一个使用ImGui的项目是一个几分钟的问题。这里显示的示例是使用Windows和Visual Studio2017，但在MacOS或Linux中非常相似。</p><p>如果您想尝试一下，可以从Connan示例中下载所有文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/conan-io/examples.git</span><br><span class="line"><span class="built_in">cd</span> examples/libraries/dear-imgui/basic</span><br></pre></td></tr></table></figure><p>首先，让我们检查CMake项目。它有GLFW和OpenGL3的绑定，还有两个文件来处理OpenGL阴影和文件读取。它还将复制每次重新编译应用程序时呈现三角形的着色器到工作目录。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.0</span>)</span><br><span class="line"><span class="keyword">project</span>(dear-imgui-conan CXX)</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>(CMAKE_PREFIX_PATH <span class="variable">$&#123;CMAKE_BINARY_DIR&#125;</span>)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_MODULE_PATH <span class="variable">$&#123;CMAKE_BINARY_DIR&#125;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># CONFIG option is important so that CMake doesnt search for modules into the default modules directory</span></span><br><span class="line"><span class="keyword">find_package</span>(imgui CONFIG)</span><br><span class="line"><span class="keyword">find_package</span>(glfw CONFIG)</span><br><span class="line"><span class="keyword">find_package</span>(glew CONFIG)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>( dear-imgui-conan </span><br><span class="line">                main.cpp </span><br><span class="line">                opengl_shader.cpp</span><br><span class="line">                file_manager.cpp</span><br><span class="line">                opengl_shader.h </span><br><span class="line">                file_manager.h </span><br><span class="line">                bindings/imgui_impl_glfw.cpp</span><br><span class="line">                bindings/imgui_impl_opengl3.cpp</span><br><span class="line">                bindings/imgui_impl_glfw.h</span><br><span class="line">                bindings/imgui_impl_opengl3.h </span><br><span class="line">                assets/simple-shader.vs</span><br><span class="line">                assets/simple-shader.fs )</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_custom_command</span>(<span class="keyword">TARGET</span> dear-imgui-conan</span><br><span class="line">    POST_BUILD</span><br><span class="line">    <span class="keyword">COMMAND</span> <span class="variable">$&#123;CMAKE_COMMAND&#125;</span> -E copy <span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/assets/simple-shader.vs <span class="variable">$&#123;PROJECT_BINARY_DIR&#125;</span></span><br><span class="line">    <span class="keyword">COMMAND</span> <span class="variable">$&#123;CMAKE_COMMAND&#125;</span> -E copy <span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/assets/simple-shader.fs <span class="variable">$&#123;PROJECT_BINARY_DIR&#125;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">target_compile_definitions</span>(dear-imgui-conan PUBLIC IMGUI_IMPL_OPENGL_LOADER_GLEW)</span><br><span class="line"></span><br><span class="line"><span class="keyword">target_link_libraries</span>(dear-imgui-conan imgui::imgui glfw::glfw glew::glew)</span><br></pre></td></tr></table></figure><p>我们还需要conanfile来声明它所依赖的库。除了GLF W库，我们还谈到了我们需要GLE W库来处理OpenGL函数加载。我们将使用cmake_multi为Debug和Release配置生成项目。还添加了一个导入部分，以下载GLFW和OpenGL3所需的绑定。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[requires]</span></span><br><span class="line">imgui/1.69@bincrafters/stable</span><br><span class="line">glfw/3.2.1@bincrafters/stable</span><br><span class="line">glew/2.1.0@bincrafters/stable</span><br><span class="line"></span><br><span class="line"><span class="section">[generators]</span></span><br><span class="line">cmake_find_package_multi</span><br><span class="line"></span><br><span class="line"><span class="section">[imports]</span></span><br><span class="line">./misc/bindings, imgui_impl_glfw.cpp -&gt; ../bindings</span><br><span class="line">./misc/bindings, imgui_impl_opengl3.cpp -&gt; ../bindings</span><br><span class="line">./misc/bindings, imgui_impl_glfw.h -&gt; ../bindings</span><br><span class="line">./misc/bindings, imgui_impl_opengl3.h -&gt; ../bindings</span><br></pre></td></tr></table></figure><p>现在让我们构建项目并运行应用程序。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> dear-imgui-conan-example</span><br><span class="line">mkdir build</span><br><span class="line"><span class="built_in">cd</span> build</span><br><span class="line">conan install .. -s build_type=Release</span><br><span class="line">conan install .. -s build_type=Debug</span><br><span class="line">cmake .. -G <span class="string">"Visual Studio 15 2017 Win64"</span></span><br><span class="line">cmake --build . --config Release</span><br><span class="line"><span class="built_in">cd</span> Release</span><br><span class="line">dear-imgui-conan</span><br></pre></td></tr></table></figure><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>Dear ImGui是一个强大的库，具有易于使用的API，它几乎无缝地集成到3D管道启用的应用程序中。它有很多小部件，可以成为一个很好的工具来制作调试软件，如分析器、记录器或任何类型的对象编辑器。此外，目前正在开发新的功能，如对接或多个视图端口。现在是时候体验Dear ImGUI了，并使它与您自己的代码交互了！</p><h3 id="参考连接"><a href="#参考连接" class="headerlink" title="参考连接"></a>参考连接</h3><ol><li><a href="https://eliasdaler.github.io/using-imgui-with-sfml-pt2/" target="_blank" rel="noopener">Using ImGui with modern C++ and STL for creating awesome game dev tools. Part 2. Some tips and tricks.</a></li><li><a href="https://github.com/ocornut/imgui" target="_blank" rel="noopener">https://github.com/ocornut/imgui</a></li><li><a href="https://blog.conan.io/2019/06/26/An-introduction-to-the-Dear-ImGui-library.html" target="_blank" rel="noopener">An introduction to the Dear ImGui library</a></li></ol><p><a href="https://conan.io/" target="_blank" rel="noopener">https://conan.io/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Dear-ImGui-library-简介&quot;&gt;&lt;a href=&quot;#Dear-ImGui-library-简介&quot; class=&quot;headerlink&quot; title=&quot;Dear ImGui library  简介&quot;&gt;&lt;/a&gt;Dear ImGui library  简介
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>费曼学习法与教学相长</title>
    <link href="https://frank2019.github.io/2020/02/27/001.%E8%B4%B9%E6%9B%BC%E5%AD%A6%E4%B9%A0%E6%B3%95-%E6%95%99%E5%AD%A6%E7%9B%B8%E9%95%BF/"/>
    <id>https://frank2019.github.io/2020/02/27/001.%E8%B4%B9%E6%9B%BC%E5%AD%A6%E4%B9%A0%E6%B3%95-%E6%95%99%E5%AD%A6%E7%9B%B8%E9%95%BF/</id>
    <published>2020-02-27T13:32:25.771Z</published>
    <updated>2020-03-04T23:47:21.419Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><blockquote><p><em>The person who says he knows what he thinks but cannot express it usually does not know what he thinks.</em></p><p>​                                                                                                               <em>— Mortimer Adler</em></p></blockquote><p>生硬翻译一下是：</p><blockquote><p> 心里感觉知道，但是不能准确的表达清楚，其实并非真正地知道。</p></blockquote><h2 id="费曼是谁？"><a href="#费曼是谁？" class="headerlink" title="费曼是谁？"></a>费曼是谁？</h2><p> <strong>理查德·费曼</strong></p><p>美国理论物理学家，量子电动力学创始人之一，纳米技术之父。</p><ul><li>他早年参与了“曼哈顿计划”，是推动世界第一颗原子弹研发的重要人物。</li><li>曾参与调查“挑战者号”航天飞机失事事件，并且在电视机前，向全美国人民用一个实验干净清晰的解释了失事原因。</li><li>他被认为是爱因斯坦之后最睿智的理论物理学家，也是第一位提出纳米概念的人。</li><li>1965年费曼因在量子电动力学方面的贡献获得诺贝尔物理学奖。</li><li>除了是个物理学家，费曼还是个作家、艺术家，擅长演奏手鼓，还擅长打开各类保险箱</li></ul><h2 id="费曼学习法"><a href="#费曼学习法" class="headerlink" title="费曼学习法"></a>费曼学习法</h2><p> 有一种学习方法被归于费曼的名下，虽然并没有事实证据是由费曼提出，但这个方法帮助了很多人快速学习一门技能。 </p><p>费曼学习法总共分四部（以下为众多版本之一）：</p><h3 id="1，Concept-（概念）"><a href="#1，Concept-（概念）" class="headerlink" title="1，Concept （概念）"></a>1，<strong>C</strong>oncept （概念）</h3><p>选择一个你要学习的<strong>概念</strong>，或者说是技能点;</p><h3 id="2，Teach-（教给别人）"><a href="#2，Teach-（教给别人）" class="headerlink" title="2，Teach （教给别人）"></a>2，<strong>T</strong>each （教给别人）</h3><p>想象把这个概念<strong>教</strong>给一个外行（或者八岁小孩）， 不使用任何高级的词汇或复杂的概念(因为使用它们时你很容易又陷入自欺的怪圈),使用小学生都可以听懂的语言。用这种方法讲授时，其实是在迫使自己更深刻的理解这个概念。同样重要的是，会发现自己在那些地方理解的还不够透彻。 </p><h3 id="3，Review-（评价）纠错学习"><a href="#3，Review-（评价）纠错学习" class="headerlink" title="3，Review （评价）纠错学习"></a>3，<strong>R</strong>eview （评价）纠错学习</h3><ul><li>在步骤二中，不可避免的遇到卡壳 或是难以解释的地方 甚至是遗漏重要的方面，</li><li>这其实是很有价值的反馈。</li><li>返回到原材料中，有针对性的学习相关的部分。<strong>评价</strong>你自己的教学并找到和原概念的差距。</li><li>然后合上原材料，重新回到步骤2.直到你完全通过步骤三。</li></ul><h3 id="4-Simplify-（简化）回顾和精简，总结"><a href="#4-Simplify-（简化）回顾和精简，总结" class="headerlink" title="4,Simplify （简化）回顾和精简，总结"></a>4,<strong>S</strong>implify （简化）回顾和精简，总结</h3><ul><li>经过前面的三步，你已经可以解释这个概念了；</li><li>现在回顾这些解释，确保你没有使用任何复杂的语言；</li><li>将这些解释大声读出来，如果听起来不够简洁，或者让人困惑，这就说明你在这些地方还可以进一步加深理解。你也可以尝试用常见事物和现象类比来解释。</li><li>最后，已经可以用最简洁清晰的语言解释清楚这个概念了。而这时，也表明你真的理解透彻这个概念的实质。</li><li>当使用这种方法时，慢慢透过这个方法的每一个步骤，精确地发现还有哪些内容没有理解。</li><li>这种学习方式非常高效，很少浪费时间。</li></ul><h3 id="5，找个实际的人试一下-可选"><a href="#5，找个实际的人试一下-可选" class="headerlink" title="5，找个实际的人试一下(可选)"></a>5，找个实际的人试一下(可选)</h3><h2 id="关于学习的话"><a href="#关于学习的话" class="headerlink" title="关于学习的话"></a>关于学习的话</h2><blockquote><p> 概念是一切知识架构的基石。所谓的“独立思考” ，对其最朴素的描述无非是：能够独立地、正确地使用正确的概念。 </p><p>​                                                                                             —-李笑来在《新生》一书                 </p></blockquote><blockquote><p>[With first principles thinking] you boil things down to the most fundamental truths … and then reason up from there.</p><p>[当你使用基本原则思维时] 你将事情追溯到最基本的真理…然后，从最基本的真理出发，向上逻辑推导。</p><p>​                                                                                                —马斯克</p></blockquote><blockquote><p> “<strong>你从头读，尽量往下读，直到你一窍不通时再从头开始，这样坚持往下读，直到你完全读懂为止</strong>”。 </p><p>–费曼</p></blockquote><blockquote><p> 董遇字季直,性质讷而好学。人有从学者,遇不肯教,而云“必当先读百遍！”言：“读书百遍，其义自见”。从学者云:“苦渴无日。”遇言“当以‘三余’。”或问“三余”之意,遇言“冬者岁之余,夜者日之余,阴雨者时之余也。 </p><p>​                                                                                                                                                            &lt;三国志&gt;</p></blockquote><blockquote><p>​     “是故学然后知不足，教然后知困。知不足然后能自反也，知困然后能自强也。故曰教学相长也。” </p><p>​                                                                                         《<a href="https://baike.baidu.com/item/礼记·学记" target="_blank" rel="noopener">礼记·学记</a>》 </p><p>PS:  这不就是费曼学习法吗？</p></blockquote><h2 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h2><p>如果你想更多的了解费曼的思想，不妨读读下面几本书。</p><ul><li><p>《别闹了，费曼先生》</p></li><li><p>《你干吗在乎别人怎么想？》</p></li><li><p>《发现的乐趣》</p></li><li><p>《费曼手札》</p></li><li><p>《费曼传》</p></li><li><p>《费曼物理学讲义》</p><p>2013年，BBC播出了一个费曼的记录片：The Fantastic Mr. Feynman，1个小时，也可以找来看看。 </p></li></ul><hr><p>公众号:  猫爪在线</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;The person who says he knows what he thinks but canno
      
    
    </summary>
    
    
      <category term="自我提升方法论" scheme="https://frank2019.github.io/categories/%E8%87%AA%E6%88%91%E6%8F%90%E5%8D%87%E6%96%B9%E6%B3%95%E8%AE%BA/"/>
    
    
      <category term="教学相长" scheme="https://frank2019.github.io/tags/%E6%95%99%E5%AD%A6%E7%9B%B8%E9%95%BF/"/>
    
      <category term="费曼" scheme="https://frank2019.github.io/tags/%E8%B4%B9%E6%9B%BC/"/>
    
      <category term="学习法" scheme="https://frank2019.github.io/tags/%E5%AD%A6%E4%B9%A0%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>教学相长</title>
    <link href="https://frank2019.github.io/2020/02/27/001.%E6%95%99%E5%AD%A6%E7%9B%B8%E9%95%BF/"/>
    <id>https://frank2019.github.io/2020/02/27/001.%E6%95%99%E5%AD%A6%E7%9B%B8%E9%95%BF/</id>
    <published>2020-02-27T13:32:25.745Z</published>
    <updated>2020-03-01T13:17:52.940Z</updated>
    
    <content type="html"><![CDATA[<p>两则典故，关于学习方法，关于教学相长。</p><h2 id="教学相长一"><a href="#教学相长一" class="headerlink" title="教学相长一"></a>教学相长一</h2><p><strong>原文</strong></p><p>虽有佳（嘉）肴，弗食，不知其旨也；虽有至道，弗学，不知其善也。是故学然后知不足，教然后知困。知不足，然后能自反也。知困，然后能自强也。故曰：教学相长也。兑命曰：“学学半。”其此之谓乎？</p><p><strong>译文</strong></p><p>即使有美味的菜肴，不吃，不会知道它的味道鲜美；即使有最好的道理，不学，不会知道它的高妙。因此，（通过）学习然后知道（自己）有不足的地方，（通过）教然后知道（自己）有困惑不解的地方。知道（自己）有不足的地方，然后（才）能够督促自己（进一步学习）；知道（自己）有困惑不解的地方，然后才能够自我奋发进取。所以说：教和学是互相促进、共同提高的。《兑命》说：教别人也是自己学习的一半。大概说的就是这个道理吧。</p><h2 id="教学相长二"><a href="#教学相长二" class="headerlink" title="教学相长二"></a>教学相长二</h2><p><strong>原文</strong></p><p>剑虽利，不厉不断；材虽美，不学不高。虽有嘉肴①，不尝不知其旨②；虽③有善道，不学不达其功。故学然后知不足，教然后知不究④。不足，故自愧而勉；不究，故尽师而熟。由此观之，则教学相长也。</p><p><strong>译文</strong></p><p>剑刃虽然锐利，不磨就不能斩断他物；人的资质虽然聪颖，不认真学习，就不能提高修养。虽然有美酒佳肴，不亲口品尝，就不能知道它们的味美；虽然有正确的道理，不努力学习，就不能通达它们的功用。所以说，通过学习，然后才会发现自己的不足；通过传授，然后才知道自己研究不深。发现自己的不足，就会心愧而努力学习，知道自己的研究不深，就会遍天下求师而弄透事理。从这些看来，传授与学习是相互促进的。</p><p>PS: 古代经典还是很有必要读的，不然死后不好意思见古人！</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ol><li><a href="https://www.jianshu.com/p/ec892fcc1261" target="_blank" rel="noopener">费曼读书法  </a></li><li><a href="https://baike.baidu.com/item/%E5%AD%A6%E8%AE%B0/1011104?fromtitle=%E7%A4%BC%E8%AE%B0%C2%B7%E5%AD%A6%E8%AE%B0&fromid=5912314" target="_blank" rel="noopener">礼记·学记</a></li><li><a href="https://baike.baidu.com/item/%E6%95%99%E5%AD%A6%E7%9B%B8%E9%95%BF/503225?fr=aladdin" target="_blank" rel="noopener">教学相长</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;两则典故，关于学习方法，关于教学相长。&lt;/p&gt;
&lt;h2 id=&quot;教学相长一&quot;&gt;&lt;a href=&quot;#教学相长一&quot; class=&quot;headerlink&quot; title=&quot;教学相长一&quot;&gt;&lt;/a&gt;教学相长一&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;原文&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;虽有佳（
      
    
    </summary>
    
    
      <category term="自我提升方法论" scheme="https://frank2019.github.io/categories/%E8%87%AA%E6%88%91%E6%8F%90%E5%8D%87%E6%96%B9%E6%B3%95%E8%AE%BA/"/>
    
    
      <category term="古文" scheme="https://frank2019.github.io/tags/%E5%8F%A4%E6%96%87/"/>
    
  </entry>
  
</feed>
